- Eager load: 
  - 线程安全，类加载就会导致该单实例对象被创建
  - 如果对象足够大，但是一直没有使用就会造成**内存浪费**（方式1, 2均会）
  - Demo1: 静态成员变量方式创建; 类加载就会导致该单实例对象被创建
  - Demo2: 静态代码块方式创建; 类加载就会导致该单实例对象被创建
  - Demo3: 枚举方式：[极力推荐]，因为枚举类型是线程安全的，并且只会装载一次。唯一一种不会被破坏的单例实现模式。



- Lazy Load:
  - Demo1: 同步锁的方式：由于大部分的操作都是read, read操作是线程安全的，所以不需要每个线程必须持有锁才能调用该方法，需要调整加锁的时机。 
  - Demo2: 双重检查锁：看似很好，但其实问题很多。在**多线程**的情况下，可能会出现空指针的问题。出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。要解决空指针问题要使用**volatile**关键字，volatile关键字可以保证可见性和有序性
    - volatile关键词的双重检查锁: 是一种比较好的单例实现模式，能够保证多线程的情况下线程安全也不会有性能问题。
  - Demo3: 静态内部类：开源项目中比较常用的一种单例模式。没有加锁的情况下，保证了多线程下的安全，且没有任何性能影响和空间的浪费。
  
- 存在的问题
  - 破坏单例模式的几种方式
    - 序列化
      
    - 反射