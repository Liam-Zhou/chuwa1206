# Homework 17

- HashMap Source Code



## JDK 7

- 创建对象过程中，底层会初始化 `Entry[] table = new Entry[16];` 数组
- 添加/修改put的过程中，把key value封装成一个Entry对象，准备添加到Entry数组

### 添加/修改put的过程

- 添加 `(key1, value1)` 到map中
- 调用key1所在类的 `hashCode()` 方法，计算key1对应的哈希值1，哈希值1经过 `hash()` 算法之后，得到哈希值2，哈希值2再经过 `indexFor()` 算法确定其在Entry数组table中的索引位置i
  - **condition 1:** 如果此位置没有元素，则 `(key1, value1)` 添加成功
  - 如果此索引位置有元素 `(key2, value2)` 则需要继续比较key1和key2的哈希值2 **(哈希冲突)**
    - **conditon 2:** 如果两者哈希值2不相同，则 `(key1, value1)` 添加成功
    - 如果哈希值2不相同，则需要继续比较 `key1.equals(key2)`
      - **condition 3:** 如果返回false，则 `(key1, value1)` 也添加成功
      - 如果返回true，则认为key1和key2是相同的，value1替换value2，return value2
- condition 1 会添加到索引位置
- condition 2、3 会从头插入，构成单向链表结构，`(key1, value1) -> (key2, value2)`

### 扩容

- 扩容条件: `(size >= threshold && null != table[i])`
- 元素个数达到临界值就考虑扩容 threshold为 `数组长度*加载因子` (加载因子默认0.75)
- 同时当前添加的位置已经有元素了，如果还是空着的先放着不着急扩
- 默认扩容为原来2倍
- 第一次扩容就是size达到 `16 * 0.75 = 12`，就把原来的16扩为32

### null key

- 允许出现一个null的key，放到索引0的位置，只有不是null的时候才计算哈希值

## JDK 8

- 创建HashMap并不会初始化table数组。当首次添加 `(key, value)` 时进行判断，如果table尚未初始化，则对数组进行初始化
- Java 8中HashMap定义了Node内部类，替代7中的Entry内部类 -> `Node[]`
- 哈希冲突拉链表时，由7中头部插入改成尾部插入，即 `(key2, value2) -> (key1, value1)`
- 底层结构由**数组+单链表**改为**数组+单链表或红黑树**
  - 什么时候会使用 [[红黑树]]？如果i位置上元素数量达到8，并且数组长度达到64，将此索引i位置上多个元素改为使用红黑树存储
  - 为什么要改？红黑树 $O(logn)$ 比单链表 $O(n)$ 在插入、修改、删除上时间复杂度要更好
  - 变回单链表: i位置元素个数低于6，因为红黑树占空间大约是单链表的2倍

## 常见属性字段

```java
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 默认初始容量 16
static final int MAXIMUM_CAPACITY = 1 << 30; // 最大容量 2^30
static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认加载因子
static final int TREEIFY_THRESHOLD = 8; // 默认链表转红黑树thresh
static final int UNTREEIFY_THRESHOLD = 6; // 默认红黑树转链表thresh
static final int MIN_TREEIFY_CAPACITY = 64; // 除了满足链表元素大于thresh还要满足最小树化容量
transient Node<K, V>[] table; // 数组
transient int size; // Entry对象个数
int threshold; // size达到threshold考虑扩容
final float loadFactor; // 加载因子
```





