## 1.  Write up Example code to demonstrate the three foundmental concepts of OOP. (reference Code Demo repo as example) Encapsulation; Polymorphism;Inheritance
```
 // Encapsulation Example code
 public class Employee {
        private String name;
        private int age;

        public Employee(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }

        public void setName(String name) {
            this.name = name;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }
  // Inheritance
  
class Animal {
    public void move() {
        System.out.println("Animal is running");
    }
}

class Bird extends Animal {
    @Override
    public void move() {
        System.out.println("The bird is flying");
    }
}


// Polymophism
class Shape {
    public void draw() {
        System.out.println("Drawing a shape");
    }
    @Overlocad
    public void draw(String name){
        System.out.println("Drawing a "+name);
    }
    
}

class Triangel extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a triangle");
    }
}

```

## 2. What is wrapper class in Java and Why we need wrapper class ?

- `Wrapper classes` are used to convert primitive data types into objects, like int to
  Integer , double to Double , etc. Converting primitive data types into object is
  called boxing, and this is taken care by the compiler
- Object Conversion: Wrapper classes allow primitive data types to be converted into objects. 
- Null Values: Primitive data types cannot be assigned a null value, but objects can. Wrapper classes can be set to null, which can be useful in scenarios where the absence of a value needs to be represented.
- Generics in Collections: When working with generics in collections, only objects can be used. Wrapper classes enable the use of primitive types in generic classes.


## 3. What is the difference between HashMap and HashTable ?
- `HashMap`: It is not synchronized, meaning it is not thread-safe. Multiple threads can access a HashMap concurrently, and if at least one of the threads modifies the map structurally (adding or removing entries), it must be synchronized externally.
- `Hashtable`: It is synchronized. All of its methods are synchronized, making it thread-safe. However, this can lead to performance overhead in a multi-threaded environment.


## 4. What is String pool in Java and why we need String pool?

- A String is a sequence of characters. In java, String objects are immutable, which
  means that once they are created, they cannot be changed.
- String objects are stored in a special memory area known as the String Pool.
  The String Pool is located in the heap memory area.
- When a String object is created, it is placed in the String Pool. If another String object
  is created with the same value, a reference to the existing String object will be returned, instead of creating a new object.


## 5. What is Java garbage collection ?

- Java garbage collection is the automatic process of identifying and reclaiming memory that is no longer in use by the program. 
  In Java, memory management is handled by the Java Virtual Machine (JVM), and the garbage collector is a part of this system.

## 6. What are access modifiers and their scopes in Java ?

- Access Modifier: specify accessibility of field, method, constructor or class. public, private, protected, default
- `public`: Scope: The member (class, method, or field) is accessible from any other class in the same project or external projects. 
- `private`: The member is only accessible within the same class. It is not accessible from outside the class, including subclasses.
- `protected`:The member is accessible within the same class, subclasses (even if they are in different packages), and by other classes in the same package.
- `default`:The member is accessible only within the same package. It is not accessible from outside the package, even if it is in a subclass.

## 7. What is final key word? (Filed, Method, Class) ?
- The final keyword can be used to make a class, method or variable immutable. Once a final variable is assigned a value, it becomes a
  constant and can no longer be changed.
- Final method: Once a method is made final, it cannot be overridden.
- Final Class: Once a class is made final, it cannot be extended


## 8. What is static keyword? (Filed, Method, Class). When do we usually use it?

- `Static Fields`:A static field is a class-level variable that is shared among all instances of the class.
                It is declared with the static keyword before the data type. All instances of the class share the same static field value.
- `Static Methods`:A static method belongs to the class rather than an instance of the class. It is declared with the static keyword before the return type.
                Static methods can be called using the class name without creating an instance of the class.
## 9. What is the differences between overriding and overloading ?
  - `Method overloading`:A class has multiple methods having same name but different in parameters,different number of parameters
     and different data type of parameters
  - `Method overriding`:A method in a subclass has the same name and return type as a method in its superclass,
    then the method in the subclass is said to override the method in the superclass
## 10. What is the differences between super and this??
- `super` refers to parent object
- `this` refers to current object

## 11.  What is the Java load sequence? ?
- `Loading`:The process begins with the loading of the class into memory.
- `linking`: Process consists of three sub-steps: verification, preparation, and resolution.
- `Verification`: The bytecode of the class is checked for integrity and security to ensure it adheres to Java specifications.
- `Preparation`:  Memory is allocated for static variables and initialized with their default values. This step is essential for both class variables (static fields) and instance variables.
- `Resolution`: Symbolic references are replaced with direct references. In other words, references to other classes or methods are resolved.
-`Initialization`:The initialization phase involves executing the static initializers and initializing static fields. This step occurs at the time of class initialization.

## 12. What is Polymorphism ? And how Java implements it ?.
- Polymorphism in java is a concept by which we can perform a single action in different
  ways. There are two types of polymorphism in java:`Compile time polymorphism`,`Runtime polymorphism`

## 13.  What is Interface and what is abstract class? What are the differences between them?
 - Definition: An abstract class is a class that cannot be instantiated and can contain both abstract and non-abstract methods. An interface, on the other hand, is a contract that specifies a set of methods that a class must implement.
- Method implementation: In an abstract class, some methods can be implemented, while others are left abstract, meaning that they have no implementation and must be overridden by concrete subclasses. In contrast, all methods in an interface are by default abstract and must be implemented by any class that implements the interface.

## 16.  What are Queue interface implementations and what are the differences and when to use what? 
- `LinkedList`:
   - Doubly linked list-based implementation. Allows null elements.
   - Use Cases:When you need a general-purpose queue and insertion and removal from both ends are frequent. 
  - `PriorityQueue`:
     - Implements the Queue interface. Priority-based implementation using a heap data structure.
        Elements are ordered based on their natural order or by a specified comparator.
  -`ArrayDeque`:
     - Implements the Queue interface. Resizable-array implementation.
     Does not have the capacity restrictions of LinkedList.
     - Use Cases:
     When you need a fast and efficient queue implementation.
     Good choice for a double-ended queue (Deque) where insertion and removal from both ends are frequent.