1. [annotations.md]()
2. :
   1. **Service Components:**
      1. Individual microservices responsible for specific business functions.
      2. Examples: user service, product service, order service.
   2. **API Gateway:**
      1. Front-end layer that routes client requests to appropriate microservices.
      2. Handles authentication, routing, load balancing, and API versioning.
      3. Examples: Netflix Zuul, Kong, AWS API Gateway.
   3. **Service Discovery:**
      1. Allows services to find and communicate with each other dynamically.
      2. Maintains a registry of available services and their locations.
      3. Examples: Netflix Eureka, Consul, etcd.
   4. **Message Broker:**
      1. Facilitates asynchronous communication between microservices.
      2. Decouples services and enables event-driven architectures.
      3. Examples: Apache Kafka, RabbitMQ, Amazon SQS.
   5. **Database per Service:**
      1. Each microservice has its own database to ensure autonomy and encapsulation.
      2. Supports polyglot persistence and database technologies best suited for each service.
      3. Examples: MySQL, PostgreSQL, MongoDB, Cassandra.
   6. **Containerization:**
      1. Packaging microservices into lightweight containers for consistency and portability.
      2. Enables rapid deployment, scaling, and management.
      3. Examples: Docker, Kubernetes, Amazon ECS.

3. Resilience patterns are design patterns and practices used to build robust and fault-tolerant software systems that can withstand and recover from failures gracefully. A circuit breaker is a resilience pattern used to prevent cascading failures in distributed systems. It typically has 3 status: Open, Close, and Half-open.

4. reading

5. 
   Load balancing in microservices is a critical aspect of building scalable and resilient distributed systems. It involves distributing incoming client requests across multiple instances of a service to ensure optimal resource utilization, high availability, and efficient handling of traffic. Here's how load balancing can be implemented in a microservices architecture:

   1. **Service Discovery and Registration:**
      - Microservices need to register themselves with a service registry when they start up.
      - The service registry maintains a dynamic list of available instances of each service.
      - Common service registries include Netflix Eureka, Consul, and etcd.
   2. **Load Balancer:**
      - A load balancer sits in front of the microservices and distributes incoming requests across multiple instances of a service.
      - Load balancers can use various algorithms to determine how to distribute the load, such as round-robin, least connections, or weighted distribution.
      - Examples of load balancers include NGINX, HAProxy, and AWS Elastic Load Balancer (ELB).
   3. **Client-Side Load Balancing:**
      - In client-side load balancing, the client is responsible for selecting a service instance to send the request to.
      - The client retrieves a list of available instances from the service registry and selects one based on a load balancing algorithm.
      - Libraries such as Ribbon (part of Netflix OSS) provide client-side load balancing capabilities.
   4. **Server-Side Load Balancing:**
      - In server-side load balancing, the load balancer is responsible for selecting a service instance to route the request to.
      - The load balancer maintains a list of available instances obtained from the service registry and uses a load balancing algorithm to select one.
      - Server-side load balancing is transparent to the client and is typically implemented using dedicated load balancing software or hardware.
   5. **Dynamic Reconfiguration:**
      - Load balancers and service registries need to dynamically adjust to changes in the availability of service instances.
      - They should monitor the health of service instances and remove or add instances from the pool as needed.
      - This ensures that traffic is always routed to healthy and responsive instances.
   6. **Redundancy and Failover:**
      - Load balancers and service registries should be redundant and resilient to prevent single points of failure.
      - They should support failover mechanisms to ensure uninterrupted service even in the event of failures or outages.

   By implementing load balancing in a microservices architecture, you can achieve better scalability, fault tolerance, and performance, enabling your system to handle varying levels of traffic and maintain high availability.

6. service discovery:
   1. **Service Registration:**
      - When a microservice starts up, it registers itself with a service registry. This registration typically includes information such as the service name, host address, port number, and health status.
      - The service registry maintains a dynamic and up-to-date list of available service instances.
   2. **Service Registry:**
      - The service registry is a centralized or distributed database or service that stores information about available service instances.
      - It provides APIs for microservices to register themselves and query for the locations of other services.
      - Common service registry implementations include Netflix Eureka, Consul, etcd, and ZooKeeper.
   3. **Service Discovery Client:**
      - Microservices and clients use a service discovery client to interact with the service registry.
      - The service discovery client retrieves information about available service instances from the registry and caches it locally for efficient access.
      - The client periodically refreshes its cache to ensure it has the latest information.
   4. **Client-Side Service Discovery:**
      - In client-side service discovery, the client is responsible for locating and selecting a service instance to communicate with.
      - The client retrieves a list of available service instances from the service registry and uses a load balancing algorithm to select one.
      - The selected instance's location (e.g., host address and port number) is then used to send requests.
   5. **Server-Side Service Discovery:**
      - In server-side service discovery, the service itself is responsible for providing its location to clients.
      - The service registers itself with the service registry upon startup and periodically updates its registration to maintain its availability status.
      - Clients query the service registry to obtain the location of the desired service instance.
   6. **Dynamic Updates and Health Checks:**
      - Service registries support dynamic updates to reflect changes in the availability or health status of service instances.
      - They often include health checks to monitor the status of service instances and remove or add instances from the registry accordingly.
7. reading

