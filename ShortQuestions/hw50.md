2. Microservice architecture

   1. Api gateway
      1. zuul
      2. Spring cloud gateway
   2. service registry
      1. eureka
      2. nacos
      3. consul
   3. config
      1. spring cloud config
   4. curcuit breaker
      1. hystrix
      2. resilience4j
   5. Message-queue
      1. kafka
   6. Load balancing
      1. nginx
      2. ribbon

3. Resiliency patterns are a type of service architecture that help to prevent cascading failures and to preserve functionality in the event of service failure.

   The circuit breaker pattern is an application resiliency pattern used to limit the amount of requests to a service based on configured thresholds â€” helping to prevent the service from being overloaded. 

4. Article

5. **Load Balancer**: A device or software that distributes network traffic across multiple servers to improve performance, availability, and scalability.

   **Types of Load Balancers**: There are three main types of load balancers: client-side, software, and hardware. Each type has its own advantages and disadvantages in terms of cost, flexibility, and capability.

   **Load Balancing Algorithms**: There are various algorithms to decide which server should handle a request, such as round-robin, weighted round-robin, least connections, least response time, and IP hash.

   **Load Balancing Categories**: Load balancers can be classified into three categories based on the OSI model: layer 4 (transport layer), layer 7 (application layer), and global server load balancing (GSLB). Each category has different features and use cases.

6. The Service Provider registers itself with the service registry when it enters the system and de-registers itself when it leaves the system.

   The Service Consumer gets the location of a provider from the service registry, and then connects it to the service provider.

   The Service Registry is a database that contains the network locations of service instances. The service registry needs to be highly available and up to date so clients can go through network locations obtained from the service registry. A service registry consists of a cluster of servers that use a replication protocol to maintain consistency.

7. - Brokers
     - topic
     - partition
   - producer
   - consumer

8. Kafka uses topic partitioning to enhance scalability. When a topic is partitioned, it is broken down into smaller fractions, and each fraction is stored on different nodes within the distributed Kafka system.

9. zookeeper is used to manage the kafka brokers, select leader of replicas and maintain the offset of consumers. In later versions of kafka, zookeeper is abandoned by kafka

10. yes

11. - Each **partition** in Kafka has exactly one server that plays the role of a **leader**.

    - The **leader** handles all **read** and **write** requests for that partition.

    - If the **replication factor** for a partition is greater than 1 (meaning there are additional replicas), those replicas act as **followers**.
    - **Followers** passively replicate the data from the **leader**.
    - They do not handle direct read or write requests from clients.

12. Topic Replication can ensure redundancy to avoid data loss. 

    ISR means in-sync Replicas. By default, a replica is considered in-sync if it has fully caught up with the leader within the last 10 seconds.

13. A consumer group is basically a group of servers that provide the same service.

    consumers in a consumer group cannot consume one same partition

14. - run zookeeper
      - `bin/zookeeper-server-start.sh config/zookeeper.properties`
    - run kafka
      - `bin/kafka-server-start.sh config/server.properties`

15. - Messaging
    - Website Activity Tracking
    - Log aggregation
    - stream processing

16. When producing messages to a Kafka topic, we can specify a **key** for each message.

    If a valid **partition number** is specified, Kafka sends the record directly to that partition.

    If no partition is explicitly specified but a **key** is present, Kafka hashes the key and uses the result to map the message to a specific partition.

    This ensures that messages with the same key end up in the same partition, preserving message order.

    If neither key nor partition is present, Kafka assigns a partition in a round-robin fashion.

17. Kafka partitions allow a topic log to be divided into multiple logs, each residing on a separate node within the Kafka cluster.

    By doing so, the work of storing messages, writing new messages, and processing existing messages can be distributed across many nodes.

    This enhances scalability and enables parallel processing of data streams.

18. RabbitMQ is a solid, general-purpose **message broker** that supports several protocols such as AMQP, MQTT, STOMP, etc. It can handle high throughput. A common use case for RabbitMQ is to handle background jobs or long-running task, such as file scanning, image scaling or PDF conversion. RabbitMQ is also used between microservices, where it serves as a means of communicating between applications, avoiding bottlenecks passing messages.

    Kafka is a message bus optimized for **high-throughput ingestion data streams** and replay. Use Kafka when you have the need to move a large amount of data, process data in real-time or analyze data over a time period. In other words, where data need to be collected, stored, and handled. An example is when you want to track user activity on a webshop and generate suggested items to buy. Another example is data analysis for tracking, ingestion, logging or security.

19. **At Most Once**: Messages delivered once, but may be lost.

    **At Least Once**: Ensures delivery, but may have duplicates.

    **Exactly Once**: Each message delivered once and only once.

20. An **unbalanced Kafka cluster** occurs when data distribution across brokers or partitions is uneven. Some brokers may be overloaded, while others remain underutilized.

    - Manual Reassignment
    - Auto Data Balancer
    - Self-Balancing Clusters

21. both

22. EmployeeSummary

23. 5 brokers. 3 partitions. 100 messages/sec

24. I produce report generation request. I consume employee summary.

25. In Kafka, an offset is a unique identifier for each message within a Kafka partition. It denotes the position of a message in the partition. The offset helps consumers keep track of their progress and ensures ordered message processing.

 