

1. What is Spring and Springboot? What is the benfits of using Srpingboot?、
   - **Spring** is a comprehensive framework that provides infrastructure support for developing Java applications. It offers features like Dependency Injection, Spring JDBC, Spring MVC, Spring Security, Spring AOP, Spring ORM, and Spring Test, which can drastically reduce the development time of an application 
   - **Spring Boot** is an extension of the Spring framework that eliminates the boilerplate configurations required for setting up a Spring application. It takes an opinionated view of the Spring platform, which paves the way for a faster and more efficient development ecosystem
   - **Benfits**: Spring Boot simplifies the development process, accelerates application development, and promotes best practices for building robust and scalable Java applications.

2. What is IOC and What is DI?
   - **IOC**: It enables a framework to take control of the flow of a program and make calls to our custom code. In the Spring framework, IOC is implemented through the Spring container, which manages the objects of the application. The container is responsible for instantiating, configuring, and managing the lifecycle of objects (beans) in the application. This inversion of control allows for better decoupling and modularity in the code.
   - **DI**: Dependency Injection is a specific type of Inversion of Control where the dependencies of a component (class or bean) are injected into it by an external entity (usually the Spring container) rather than the component creating its dependencies. This helps in achieving loose coupling between components and makes the system more maintainable and testable.
     - **Constructor Injection:** Dependencies are injected through the constructor of a class.
     - **Setter Injection:** Dependencies are injected through setter methods.
     - **Method Injection:** Dependencies are injected through methods.

3. What is @CompnonentScan?

   - @ComponentScan` is an annotation in the Spring framework that is used to specify the packages that Spring should scan for annotated components. By default, Spring scans the package of the class annotated with `@SpringBootApplication` and its sub-packages. If you want to scan additional packages, you can specify them using the `basePackages` or `basePackageClasses` attributes of `@ComponentScan

4. How to define which package spring need to scan in xml and annotaiton?

   - XML:

     ```xml
     <!-- applicationContext.xml -->
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:context="http://www.springframework.org/schema/context"
            xsi:schemaLocation="http://www.springframework.org/schema/beans
                                http://www.springframework.org/schema/beans/spring-beans.xsd
                                http://www.springframework.org/schema/context
                                http://www.springframework.org/schema/context/spring-context.xsd">
     
         <!-- Specify the package to scan -->
         <context:component-scan base-package="com.example"/>
     
         <!-- Other bean definitions go here -->
     
     </beans>
     
     ```

   - Annotation:

     ```java
     @ComponentScan("com.example.myapp")
     @SpringBootApplication
     public class MyApp {
         // ...
     }
     or
     @ComponentScan(basePackageClasses = {MyComponent.class, MyOtherComponent.class})
     @SpringBootApplication
     public class MyApp {
         // ...
     }
     
     ```

     

5. What is @SpringbootApplication?

   - `@SpringBootApplication` is a convenience annotation in the Spring Framework that combines three commonly used annotations: `@Configuration`, `@EnableAutoConfiguration`, and `@ComponentScan`. 

6. How many ways wo can define a bean?

   - Beans can be defined using Java configuration classes annotated with `@Configuration`. In these classes, methods annotated with `@Bean` return instances of beans, and the method name is used as the bean ID.

     - ```java
       @Configuration
       public class AppConfig {
       
           @Bean
           public MyBean myBean() {
               // Bean instantiation and configuration
               return new MyBean();
           }
       }
       ```

   - `@Component`, `@Service`, `@Repository`, or `@Controller`

7. What is default bean name for @Component and @Bean?

   - **`@Component`:**When you annotate a class with `@Component`, the **default bean name** is the **uncapitalized** version of the **class name**. For example, if the class is named `MyComponent`, the default bean name will be `myComponent`.
   - **`@Bean`:**When you use the `@Bean` annotation on a method within a `@Configuration` class, the default bean name is the name of the method.
   - It's important to note that bean names are case-sensitive. If you want to explicitly specify a custom name for a bean, you can use the `name` attribute of the `@Component` or `@Bean` annotation.

8. What is the difference between @component and @service,@repository?

   - @Component is a generic stereotype for any Spring-managed component. It can be used across the application to mark the beans as Spring’s managed components. Spring will only pick up and register beans with @Component, and doesn’t look for @Service and @Repository in general
   - @Service is a specialization of @Component and is used to annotate classes at the service layer. It is typically used to define a business logic layer in the application 
   - @Repository is also a specialization of @Component and is used to annotate classes at the persistence layer, which will act as a database repository. It provides additional functionality such as automatic translation of exceptions 

9. How many annotaitons we can use to inject the bean?

   - 
     In Spring, there are several annotations that you can use to inject beans into other beans or components. Here are some of the commonly used annotations for dependency injection:

     1. **`@Autowired`:**

        - Used to automatically inject a bean by type.
        - Can be applied to fields, setter methods, or constructors.
        - Supports both field-based injection and method-based injection.

        ```
        javaCopy code
        @Autowired
        private MyBean myBean;
        ```

     2. **`@Qualifier`:**

        - Used in conjunction with `@Autowired` to specify the name of the bean to be injected when multiple beans of the same type exist.
        - Can be applied to fields, setter methods, or constructors.

        ```
        javaCopy code
        @Autowired
        @Qualifier("specificBean")
        private MyBean myBean;
        ```

     3. **`@Resource`:**

        - Used to inject a bean by name.
        - Can be applied to fields, setter methods, or constructors.
        - Supports both name-based and type-based injection.

        ```
        javaCopy code
        @Resource(name = "myBean")
        private MyBean myBean;
        ```

     4. **`@Inject`:**

        - Similar to `@Autowired` but is part of the Java Dependency Injection (JSR-330) standard.
        - Can be applied to fields, setter methods, or constructors.

        ```
        javaCopy code
        @Inject
        private MyBean myBean;
        ```

     5. **Constructor Injection:**

        - You can use constructor injection by directly declaring dependencies in the constructor parameters.
        - It is a recommended practice for injecting dependencies when using `@Autowired`.

        ```
        javaCopy code
        @Autowired
        public MyClass(MyBean myBean) {
            this.myBean = myBean;
        }
        ```

     6. **Setter Injection:**

        - You can use setter methods annotated with `@Autowired` for injection.

        ```
        javaCopy code
        @Autowired
        public void setMyBean(MyBean myBean) {
            this.myBean = myBean;
        }
        ```

10. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?

    - **Constructor Injection:**

      - Dependencies are injected through the constructor of a class.

      - This is considered a recommended practice as it ensures that the dependent object is fully initialized before the class is used.

      - Constructor injection promotes immutability and makes it clear what dependencies are required for an object to function.

        Example:

      ```java
      public class MyClass {
          private final MyDependency myDependency;
      
          public MyClass(MyDependency myDependency) {
              this.myDependency = myDependency;
          }
      
          // Other methods using myDependency
      }
      ```

    - **Setter Injection:**

      - Dependencies are injected through setter methods.
      - Provides flexibility, as dependencies can be changed after the object is created.
      - Can be useful when dealing with optional dependencies or when a mutable state is desired.

      Example:

      ```java
      
      public class MyClass {
          private MyDependency myDependency;
      
          @Autowired
          public void setMyDependency(MyDependency myDependency) {
              this.myDependency = myDependency;
          }
      
          // Other methods using myDependency
      }
      ```

    - **Method Injection:**

      - Dependencies are injected through methods other than the constructor or setter methods.
      - This can be useful for injecting dependencies for specific operations within a class.
      - It provides flexibility but may not be as clear as constructor injection in terms of expressing the required dependencies.

      Example:

      ```java
      
      public class MyClass {
          public void performOperation(@Autowired MyDependency myDependency) {
              // Perform operation using myDependency
          }
      }
      ```

    -  constructor injection is generally recommended for its benefits in terms of clarity, immutability, testing and ensuring that the object is in a valid state from the beginning.

11. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay.

    - When there are multiple beans of the same type, Spring can use the `@Primary` annotation to indicate which bean should be given preference. To use this annotation, you can add it to the bean definition of the primary bean
    - If there is no primary bean explicitly set, and there is no default bean based on order values, Spring will throw an exception when trying to inject the dependency. To handle this situation, you can use the `@Qualifier` annotation to specify the name of the bean you want to inject:

12. What is the difference between BeanFactory and ApplicationContext in Spring?

    - In the Spring framework, BeanFactory and ApplicationContext are two IOC containersBeanFactory is the most basic version of IOC containers, while ApplicationContext extends the features of BeanFactory. While both `BeanFactory` and `ApplicationContext` serve as containers for managing beans, `ApplicationContext` is a more feature-rich and powerful extension of `BeanFactory`. For most applications, `ApplicationContext` is the preferred choice due to its enhanced capabilities and integrations with other Spring modules.

13. What is the Scope of a Bean? and list the examples for each scope.

    - **Singleton Scope:**

      - A single instance of the bean is created for the entire container.

      - The same bean instance is reused for every request to the container that requires the bean.

      - Example:

        ```
        javaCopy code
        @Component
        @Scope("singleton")
        public class MySingletonBean {
            // Bean logic
        }
        ```

    - **Prototype Scope:**

      - A new instance of the bean is created every time it is requested from the container.

      - Each request for the bean results in the creation of a new, independent instance.

      - Example:

        ```
        javaCopy code
        @Component
        @Scope("prototype")
        public class MyPrototypeBean {
            // Bean logic
        }
        ```

    - **Request Scope:**

      - A single instance of the bean is created for each HTTP request in a web application.

      - The bean is available and active during the processing of a single HTTP request.

      - Example (for web applications):

        ```
        javaCopy code
        @Component
        @Scope("request")
        public class MyRequestScopedBean {
            // Bean logic
        }
        ```

    - **Session Scope:**

      - A single instance of the bean is created for each user session in a web application.

      - The bean is available and active throughout the user's session.

      - Example (for web applications):

        ```
        javaCopy code
        @Component
        @Scope("session")
        public class MySessionScopedBean {
            // Bean logic
        }
        ```

    - **Global Session Scope:**

      - Similar to session scope, but applicable in a Portlet-based environment (portlets in a portal).

      - A single instance of the bean is created for each user's global session.

      - Example (for web applications with Portlet support):

        ```
        javaCopy code
        @Component
        @Scope("globalSession")
        public class MyGlobalSessionScopedBean {
            // Bean logic
        }
        ```

    - **Application Scope:**

      - A single instance of the bean is created for the entire lifecycle of the application.

      - The bean is created when the application starts and remains active until the application is shut down.

      - Example:

        ```
        javaCopy code
        @Component
        @Scope("application")
        public class MyApplicationScopedBean {
            // Bean logic
        }
        ```

14. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? (you can google the tutorial how to configure beans in xml, and feel free to ask me any quesitons if you don't understand. it is a little bit old, I am not sure if I need to exaplain it in class)

    ```java
    public class MyBean {
        private String name;
        private int age;
    
        public MyBean(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        // Getters and setters
    }
    ```

    ```xml
    <!-- applicationContext.xml -->
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                               http://www.springframework.org/schema/beans/spring-beans.xsd">
    
        <!-- Configuring MyBean with parameters -->
        <bean id="myBean" class="com.example.MyBean">
            <constructor-arg name="name" value="John"/>
            <constructor-arg name="age" value="25"/>
        </bean>
    
    </beans>
    
    ```

    
