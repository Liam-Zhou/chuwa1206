4. JPA is Java persistent API. It's an ORM framework interface. Hibernate is an ORM framework, which is an JPA implementation.

5. Hikari is a JDBC connection pool project. We can reduce the number of expensive database trips by using Connection Pooling to reuse several existing connections. As a result, our database-driven applications perform better overall.

6. They are annotations indicating relationships between two tables.

   - @OneToOne: user -> user profile
   - @ManyToOne: orders -> user
   - @ManyToMany: class -> students

7. - Persist: owning entity saved => related entity saved
   - Merge: Owning entity merged => related entity merged
   - Refresh: Owning entity refreshed => related entity refreshed
   - Remove: Owning entity removed => related entity removed
   - Detach: Owining entity manually detached => related entity detached

   orphanRemoval means when an related entity is removed from owning entity, the corresponding record will be deleted from database. When it's set to false, the corresponding record's foreign key is set to null.

8. FetchType defined the action when to query related entity when loading owning entity. Lazy means query when use. Eager means query when owning entity is loaded.

9. JPA can translate method naming consists of keywords and fields in to sql query.

   We don't need to implement the methods, declaring is enough.

   `Optional<Account> findByAccountNumber(long accountNumber);`

   `findByAccount_AccountNumberAndDateTimeBetween(...)`

- 13. The Jakarta Persistence Query Language is a platform-independent object-oriented query language defined as part of the Jakarta Persistence specification. JPQL is used to make queries against entities stored in a relational database.

14. A named query is a statically defined query with a predefined unchangeable query string. They’re validated when the session factory is created, thus making the application to fail fast in case of an error.

    If we have more than one named query for an entity, we’ll use the *@NamedQueries* annotation to group these.

15. @Query is used to write your own complex query using JPQL or SQL.

    We use it in repository interface.

16. HQL or Hibernate Query Language is the object-oriented query language of Hibernate Framework.

17. EntityManager is part of the Java Persistence API. It is used to create and remove persistent entity instances, to find entities by their primary key, and to query over entities. Spring data JPA is implemented based on EntityManager.

18. The hibernate session acts as a buffer between the application and the database. It caches objects retrieved from the database so it can provide those objects if they're needed again without hitting the database.

    the SessionFactory in Hibernate is responsible for the creation of Session objects.

19. A transaction is a unit of work. The works are either all succeed or all fail. A transaction is associated with a Session and is usually instantiated by a call to Session.beginTransaction() and end by transaction.commit() or transaction.rollback(). Or we can use @Transactional.

20. Hibernate Cache saves entitys in cache and can be very useful in gaining fast application performance if used correctly. The idea behind cache is to reduce the number of database queries, hence reducing the throughput time of the application.

21. First-level cache is session cache. Second-level cache is factory cache.

22. The `@Transactional` annotation is metadata that specifies that an interface, class, or method must have transactional semantics (for example, "start a brand new read-only transaction when this method is invoked, suspending any existing transaction").

