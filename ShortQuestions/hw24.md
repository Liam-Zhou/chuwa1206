#### 2.Explain what is volatile in java? (we also use it in Singleton)

`volatile` key word in Java is used to indicate that a variable will be accessed and modified by multiple threads. It make a variable be able to be visited by worker threads from the main memory instead of CPU cache, so that every thread will get the latest value of this variable. This guarantees visibility of changes to variables across threads.

#### 3.How to create a new thread(Please also consider Thread Pool approach)?

1. Extending the Thread Class by overriding the run method, then create an instance and call start() method for the new created thread.
2. Implementing the Runnable Interface by overriding  the run method. Then pass a new created Runnable instance to a new Thread object (new Thread ( Runnable instance ) ).And call thread.start().
3. Using executors and ExecutorService to create a thread pool wth some number of threads. Use .submit() to submit a task to the job queue for available threads to finish.

#### 4.Difference between Runnable and Callable?

Runnable: A functional  interface, only has run() method to be finished. Can be used to define the thread task. Cannot return values, return type must be void, cannot throw any exceptions.

Callable: A functional interface, only has call() method. Also be used to define thread task. Can return generic values and throw exceptions.

#### 5.What is the difference between t.start() and t.run()?

t.start():  It will first create a new thread, then call run() method in the new thread. Each thread only call start() once.

t.run(): It just means running a task in the current thread and will not create a new thread. It can be called many times in a thread.

#### 6.Which way of creating threads is better: Thread class or Runnable interface?

Extending a runnable interface is better because it allows for greater flexibility and code reusability. 

If define an extended Thread class to start a new thread, then later all I can do is creating this kind of threads. But by implementing runnable interfaces, I can define other Thread class if needed by passing the same Runnable instance.

#### 7.What are the thread statuses?

New: The thread has been created, not yet started.

Runnable: Running or ready to run.

Blocked: Wait for a monitor lock to enter/reenter a synchronized block/method.

Waiting: Wait indefinitely until other threads perform an action. Wait(). join()

Timed waiting: wait for a specified amount of time.

Terminated: Completed execution.

#### 8.What is deadlock?

Dead lock means there are some threads, each holding a monitor lock, but also waiting for others' lock to continue executing.  When the waiting status becomes a cycle, a dead lock happens. For two threads situation, if thread A holds lock 1, and waits to acquire lock2, while thread B holds lock 2,  and is waiting to acquire lock 1, then a dead lock happens.

#### 9.How do threads communicate each other?

threads can use notify(), notifyAll(), wait(), to decide to release its lock and wait, or notify other threads with the same lock to wake up and attempt to acquire the lock.

#### 10.Whatâ€™s the difference between class lock and object lock?

Class lock is locking at the whole class. Object lock is locking at each instance of the class. One class has only one class lock, but can have many object lock. Static method or block (class scope) in a class need a class lock, while non-static method or block (object scope) need an object lock.

#### 11.What is join() method?

In A thread, calling B.join() means A thread will pause execution until B thread finish its running. It is very useful to ensure that the execution of threads proceeds in a controlled sequence.

#### 12.what is yield() method

yield() gives thread scheduler a suggestion to pause the execution of current thread, and give another threads(in runnable status) a chance to run and switch current thread to runnable status. But it is not guaranteed.    One thread cannot switch to anther thread by yield() if anthor thread is in waiting or blocked status.

#### 13.What is ThreadPool? How many types of ThreadPool? What is the TaskQueue in ThreadPool?

Thread Pool is a group of pre-initialized reusable threads that are able to execute tasks. TaskQueue is a blocking queue to submit jobs for available threads to run. 

FixedThreadPool: has a fixed number of threads

CachedThreadPool: creates new thread as needed

SingleThreadPool: has only one thread

#### 14.Which Library is used to create ThreadPool? Which Interface provide main functions of thread-pool?

Library: java.util.concurrent.  Using Executor framework and ExecutorService interface.

#### 15.How to submit a task to ThreadPool?

executorSerivce.submit(task). The task can be a Runnable or Callable object. It will return a Future object.

#### 16.What is the advantage of ThreadPool?

It has a taskQueue and a collection of threads to asynchronously manage thread tasks running, maximizing the use of each thread's time and CPU time. Moreover, it prevents overhead of thousands of threads creations if there comes thousands of short-lived asynchronous tasks.

#### 17.Difference between shutdown() and shutdownNow() methods of executor

Shutdown() makes sure that all previously submitted tasks will be completed, but no new tasks are accepted.

ShudownNow() will stop executing tasks, and discardi all waiting tasks, and returns a list of the tasks that are awaiting execution.

#### 18.What is Atomic classes? How many types of Atomic classes? Give me some code example of Atomic classes and its main methods. when to use it?

Atomic class provides a way to perform atomic operations on a variable without using synchronization.

AtomicInteger, AtomicLong, AtomicBoolean, AtomicIntegerArray

```Java
public class AtomicClass {
	private AtomicInteger number = new AtomicInteger(0);
	public void set(int x){
		number.set(x);
	}
	public int get(){
		return number.get();
	}
	public int incrementAndGet(){
		return number.incrementAndGet();
	}
}
```

When to use:   To perform atomic operations without the overhead of using synchronization in multi-thread environment.

#### 19.What is the concurrent collections? Can you list some concurrent data structure (Thread-safe)

Concurrent collections are based on collections, but they are thread-safe in multi-thread environment. They can be used by multiple threads safely without using synchronization.

ConcurrentHashMap

ConcurrentLinkedQueue

CopyOnWriteArrayList

#### 20.What kind of locks do you know? What is the advantage of each lock?

Synchronized Block/method: easy to use

reentrant lock: provide more flexibility than synchronized block/method.

ReadWriteLock: There are read lock and write lock. Read lock can be shared with Read lock. But no other locks can be shared with a Write lock.

#### 21.What is future and completableFuture? List some main methods of ComplertableFuture.

Future is to let current thread wait to get the called thread's return value.

completableFuture can asynchronously let current thread keep executing, don't have to wait until the called thread end.

- `supplyAsync(Supplier)`: Asynchronously computes a value using the provided Supplier.
- `thenApply(Function)`: Applies a function to the result of the computation when it completes.
- `thenAccept(Consumer)`: Consumes the result of the computation when it completes.
- `thenCombine(CompletionStage, BiFunction)`: Combines the result of this future with another asynchronous computation.
- `exceptionally(Function)`: Handles any error that occurs during the computation.
- `allOf(CompletableFuture...)` and `anyOf(CompletableFuture...)`: Used to combine multiple CompletableFutures.



