##### 2. Explain what is volatile in java? (we also use it in Singleton)

volatile is a keyword to make sure variable's visibility. Changes of volatile variable can be seen by other threads immediately.

##### 3. How to create a new thread(Please also consider Thread Pool approach)?

- Extends Thread
- use Runnable
- use Callable
- submit tasks to thread pool

##### 4. Difference between Runnable and Callable?

Callable has return value while runnable doesn't

##### 5. What is the difference between t.start() and t.run()?

t.run() is simply a method call within the current thread.

t.start() is implemented by the Thread class and will create new thread.

##### 6. Which way of creating threads is better: Thread class or Runnable interface?

Runnable interface is better because  we can separate the logic of the thread from its execution and share the same task among multiple threads.

##### 7. What are the thread statuses?

- new
- runnable
- blocked
- waiting
- time_waiting
- terminated

##### 8. What is deadlock?

A deadlock is a situation where a set of processes are blocked because each process is holding a resource and waiting for another resource acquired by some other process. 

##### 9. How do threads communicate each other?

- wait()
- notify
- notifyAll()

##### 10. What’s the difference between class lock and object lock?

Class lock will lock every static method within the class, while object lock will lock  non-static method within the given instance.

##### 11. What is join() method?

Wait for the thread to end.

##### 12. what is yield() method

*yield()* provides a mechanism to inform the “scheduler” that the current thread is willing to relinquish its current use of processor but it’d like to be scheduled back soon as possible.

##### 13. What is ThreadPool? How many types of ThreadPool? What is the TaskQueue in ThreadPool?

Thread pool is a tool to maintain and reuse a set of threads without repeatedly create and destroy threads. 

- FixedThreadPool
- CachedThreadPool
- SingleThreadExecutor

TaskQueue is a queue to maintain the tasks that are not yet assigned to threads.

##### 14. Which Library is used to create ThreadPool? Which Interface provide main functions of thread-pool?

Executors.

ExecutorService.

##### 15. How to submit a task to ThreadPool?

ExecutorService.submit()

##### 16. What is the advantage of ThreadPool?

thread creation and destruction overhead is restricted to the initial creation of the pool, which may result in better performanceand better system stability.

##### 17. Difference between shutdown() and shutdownNow() methods of executor

- shutdown will wait for the tasks to complete.
- showdownnow will immediately stop the tasks in running.

##### 18. What is Atomic classes? How many types of Atomic classes? Give me some code example of Atomic classes and its main methods. when to use it?

Atomic classes are thread-safe wrapper classes of primitive variables, providing get, set, increment etc. based on CAS.

- AtomicInteger
- AtomicLong
- AtomicBoolean
- AtomicReference

```java
public class SafeCounterWithoutLock {
    private final AtomicInteger counter = new AtomicInteger(0);
    
    int getValue() {
        return counter.get();
    }
    
    void increment() {
        counter.incrementAndGet();
    }
}
```

when dealing with shared data that can be accessed and modified by multiple threads concurrently.

##### 19. What is the concurrent collections? Can you list some concurrent data structure (Thread-safe)

Thread-safe collections within java.util.concurrent.

- CopyOnWriteArrayList
- ConcurrentHashMap
- CopyOnWriteArraySet

##### 20. What kind of locks do you know? What is the advantage of each lock?

- ReentrantLock
  - same thread can acquire the lock multiple times.
- ReadWriteLock
  - Allow multiple read threads.
- StampedLock
  - allow write when read lock is set.

##### 21. What is future and completableFuture? List some main methods of ComplertableFuture.

Future is an interface used to hold the result of a Callable task.

CompletableFuture is a class used to execute callbacks when task is done.

##### 23. *OddEventPrinter*

a. *synchronized and wait notify*

```java
()->{
            synchronized (monitor) {
                while (value <= 10) {
                    System.out.println(Thread.currentThread().getName() + ": " + value++);
                    monitor.notify();
                    try {
                        if (value <= 10) {
                            monitor.wait();
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
```

b. *ReentrantLock and await, signal*

```
public void run() {
            lock.lock();
            try {
                while (value <= 10) {
                    System.out.println(Thread.currentThread().getName() + ": " + value++);
                    c.signalAll();
                    try {
                        if (value <= 10) {
                            c.await();
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } finally {
                lock.unlock();
            }

        }
```

##### 24. Three threads

```java
public class PrintNumber1 {
    private static int n = 1;

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> printNumber());
        Thread t2 = new Thread(() -> printNumber());
        Thread t3 = new Thread(() -> printNumber());

        t1.start();
        t2.start();
        t3.start();
    }

    private static synchronized void printNumber() {
        int count = 10;
        while (count-- > 0) {
            System.out.println(Thread.currentThread().getName() + ": " + n++);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        PrintNumber1.class.notifyAll();
    }
}
```

##### 25. CompletableFuture

a.

```java
public class Hw2425a {
    private static final int a=2;
    private static final int b=3;
    public static void main(String[] args) {
        FutureTask<Integer> ft1=new FutureTask<>(()-> a+b);
        FutureTask<Integer> ft2=new FutureTask<>(()-> a*b);
        Thread t1=new Thread(ft1);
        Thread t2=new Thread(ft2);
        t1.start();
        t2.start();

        try {
            System.out.println(ft1.get());
            System.out.println(ft2.get());
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(e);
        }
    }
}
```

b+c.

```java
public class Hw2425bc {
    public static String[] urls=new String[]{
            "my-json-server.typicode.com/user/user/repo/product",
            "my-json-server.typicode.com/user/user/repo/inventory",
            "my-json-server.typicode.com/user/user/repo/review"
    };
    public static void main(String[] args) throws InterruptedException {
        ExecutorService es = Executors.newFixedThreadPool(3);
        CompletableFuture<String>[] cfs=new CompletableFuture[3];
        for(int i=0;i<3;i++){
            String url=urls[i];
            cfs[i]=CompletableFuture.supplyAsync(()->{
                try {
                    return request(url);
                }catch (Exception e){
                    throw e;
                }
            },es);
            cfs[i].exceptionally((e)-> "default").thenAccept(System.out::println);
        }
        for(CompletableFuture<String> cf:cfs){
            while(!cf.isDone()){
                Thread.sleep(100);
            }
        }
    }

    //mock get method
    private static String request(String url){
        //do nothing
        return "this is json";
    }
}
```

