1.  Read: https://www.interviewbit.com/multithreading-interview-questions/#class-level-lock-vs-object-level-lock
2.  Explain what is volatile in java? (we also use it in Singleton)

    "Volatile" tells the compiler not to cache the value of the variable as the value may change outside of the scope of the program itself.

3.  How to create a new thread (Please also consider Thread Pool approach)?

```
Thread thread = new Thread();

// Thread pool
ThreadService executer = Executors.newFixedThreadPool(4);
executer.submit(() -> "Hello World");
```

4.  Difference between Runnable and Callable?

    - Runnable Interface
      - functional interface that contains a single run() method
      - does not accept/return values
      - no "throws" clause - cannot propagate checked exceptions
    - Callable Interface
      - generic interface that contains a single call() method
      - returns a generic value V
      - can propagate checked exceptions

5.  What is the difference between t.start() and t.run()?

    start creates a new thread while run does not

6.  Which way of creating threads is better: Thread class or Runnable interface?

    Runnable

7.  What are the thread statuses?

    - New
    - Runnable
    - Blocked
    - Waiting
    - Timed_waiting
    - Terminated

8.  What is deadlock?

    A situation where a set of processes are blocked because each process is holding a resource and waiting for another resource acquired by some other process.

9.  How do threads communicate each other?

    Wait notify, locks

10. What’s the difference between class lock and object lock?

    Class lock oversees shared resources while object locks help control access to individual items

11. What is join() method?

    Main thread waits for all other thread to finish running.

12. what is yield() method?

    If any other thread needs to run the current thread will let that thread to run.

13. What is ThreadPool? How many types of ThreadPool? What is the TaskQueue in ThreadPool?

    A set of threads that perform works upon request.

    - FixedThreadPool
    - CachedThreadPool
    - SingleThreadExecutor

    The task queue holds a set of tasks to be finished by threads in the thread pool.

14. Which Library is used to create ThreadPool? Which Interface provide main functions of thread-pool?

    java.util.concurrent

    java.util.concurrent.Executor\
    java.util.concurrent.ExecutorService

15. How to submit a task to ThreadPool?

```
ThreadService executer = Executors.newFixedThreadPool(4);
executer.submit(() -> "Hello World");
```

16. What is the advantage of ThreadPool?

    Can control the number of threads within the process.

17. Difference between shutdown() and shutdownNow() methods of executor

    - shutdown() allows previously submitted tasks to execute before terminating
    - shutdownNow() prevents waiting tasks from starting and attempts to stop running tasks

18. What is Atomic classes? How many types of Atomic classes? Give me some code example of Atomic classes and its main methods. when to use it?

    Atomic classes provide a lock-free and thread-safe environment or programming on a single variable.

    - AtomicBoolean
    - AtomicInteger
    - AtomicLong

    ```
    addAndGet(int delta)
    incrementAndGet()
    getAndSet(int newValue)
    getAndIncrement()
    ```

    We use it when there is a multithreading need

19. What is the concurrent collections? Can you list some concurrent data structure (Thread-safe)

    Collections that are thread-safe.

    - CopyOnWriteArrayList
    - ConcurrentHashMap
    - CopyOnWriteArraySet
    - ArrayBlockingQueue / LinkedBlockingQueue
    - LinkedBlockingDequeue

20. What kind of locks do you know? What is the advantage of each lock?

    - ReentrantLock
      - One thread can acquire a lock multiple times
    - ReadWriteLock
      - Allows multiple read actions from different threads if there is no write action
    - StampedLock
      - No locking is performed

21. What is future and completableFuture? List some main methods of CompletableFuture.

    They hold the result from an execution of a thread.

    - ThenAccept()
    - exceptionally()

22. Type the code by your self and try to understand it. (package com.chuwa.tutorial.t08_multithreading)
23. Write a code to create 2 threads, one thread print 1,3,5,7,9, another thread print 2,4,6,8,10. (solution is in com.chuwa.tutorial.t08_multithreading.c05_waitNotify.OddEventPrinter)

    ```
    Thread-0: 1
    Thread-1: 2
    Thread-0: 3
    Thread-1: 4
    Thread-0: 5
    Thread-1: 6
    Thread-0: 7
    Thread-1: 8
    Thread-0: 9
    Thread-1: 10
    Process finished with exit code 0
    ```

    a. One solution use synchronized and wait notify

    ```
    public class OddEventPrinterCopy {
        private static final Object monitor = new Object();
        private static int value = 1;

        public static void main(String[] args) {
            Runnable runnable = new PrintRunnable();
            new Thread(runnable).start();
            new Thread(runnable).start();
        }

        static class PrintRunnable implements Runnable {

            @Override
            public void run() {
                synchronized (monitor) {
                    while (value <= 10) {
                        System.out.println(Thread.currentThread().getName() + ": " + value++);
                        monitor.notify();
                        try {
                            if (value < 11) {
                                monitor.wait();
                            }
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
    ```

    b. One solution use ReentrantLock and await, signal

    ```
    public class OddEventPrinterCopy {
        private final static ReentrantLock lock = new ReentrantLock();
        private final static Condition condition = lock.newCondition();
        private static int value = 1;

        public static void main(String[] args) {
            Runnable runnable = new PrintRunnable();
            new Thread(runnable).start();
            new Thread(runnable).start();
        }

        static class PrintRunnable implements Runnable {

            @Override
            public void run() {
                while (value < 11) {
                    lock.lock();
                    System.out.println(Thread.currentThread().getName() + ": " + value++);
                    condition.signal();
                    try {
                        if (value < 11) {
                            condition.await();
                        }
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    } finally {
                        lock.unlock();
                    }
                }
            }
        }
    }

    ```

24. create 3 threads, one thread output 1-10, one thread output 11-20, one thread output 21-22. threads run sequence is random. (solution is in com.chuwa.exercise.t08_multithreading.PrintNumber1)

    ```
    Thread-0: 1
    Thread-0: 2
    Thread-0: 3
    Thread-0: 4
    Thread-0: 5
    Thread-0: 6
    Thread-0: 7
    Thread-0: 8
    Thread-0: 9
    Thread-0: 10
    Thread-2: 11
    Thread-2: 12
    Thread-2: 13
    Thread-2: 14
    Thread-2: 15
    Thread-2: 16
    Thread-2: 17
    Thread-2: 18
    Thread-2: 19
    Thread-2: 20
    Thread-1: 21
    Thread-1: 22
    Thread-1: 23
    Thread-1: 24
    Thread-1: 25
    Thread-1: 26
    Thread-1: 27
    Thread-1: 28
    Thread-1: 29
    Thread-1: 30
    ```

    ```
    public class OddEventPrinterCopy {
        private final static ReentrantLock lock = new ReentrantLock();
        private static int value = 1;

        public static void main(String[] args) {
            Runnable runnable = new PrintRunnable();
            new Thread(runnable).start();
            new Thread(runnable).start();
            new Thread(runnable).start();
        }

        static class PrintRunnable implements Runnable {

            @Override
            public void run() {
                lock.lock();
                for (int i = 0; i < 10; i++) {
                    System.out.println(Thread.currentThread().getName() + ": " + value++);
                }
                lock.unlock();
            }
        }
    }
    ```

25. completable future:

    a. Homework 1: Write a simple program that uses CompletableFuture to asynchronously get the sum and product of two integers, and print the results.

    ```
    public class AddMult {
        public static void main(String[] args) {
            int a = 3, b = 5;
            CompletableFuture<Integer> cfa = CompletableFuture.supplyAsync(() -> getSum(a, b));
            CompletableFuture<Integer> cfm = CompletableFuture.supplyAsync(() -> getMult(a, b));

            cfa.thenAccept((res) -> System.out.println("sum: " + res));
            cfm.thenAccept((res) -> System.out.println("product: " + res));
            System.out.println("hi");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
        }
        static int getSum(int a, int b) {
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
            }
            return a + b;
        }
        static int getMult(int a, int b) {
            try {
                Thread.sleep(400);
            } catch (InterruptedException e) {
            }
            return a * b;
        }
    }
    ```

    b. Homework 2: Assume there is an online store that needs to fetch data from three APIs: products, reviews, and inventory. Use CompletableFuture to implement this scenario and merge the fetched data for further processing. (需要找 public api 去模拟，)

        i. Sign In to Developer.BestBuy.com

        ii. Best Buy Developer API Documentation (bestbuyapis.github.io)

        iii. 可以⽤fake api https://jsonplaceholder.typicode.com/

    c. Homework 3: For Homework 2, implement exception handling. If an exception occurs during any API call, return a default value and log the exception information.

    ```
    public class MergeAPI {
        public static void main(String[] args) {
            CompletableFuture<String> api1 = CompletableFuture.supplyAsync(() -> {
                StringBuilder result = new StringBuilder();
                HttpURLConnection conn;
                try {
                    URL url = new URL("https://jsonplaceholder.typicode.com/posts/1");
                    conn = (HttpURLConnection) url.openConnection();
                    conn.setRequestMethod("GET");
                } catch (MalformedURLException e) {
                    throw new RuntimeException(e);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }

                try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
                    for (String line; (line = reader.readLine()) != null; ) {
                        result.append(line);
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                return result.toString();
            });

            CompletableFuture<String> api2 = CompletableFuture.supplyAsync(() -> {
                StringBuilder result = new StringBuilder();
                HttpURLConnection conn;
                try {
                    URL url = new URL("https://jsonplaceholder.typicode.com/posts/2");
                    conn = (HttpURLConnection) url.openConnection();
                    conn.setRequestMethod("GET");
                } catch (MalformedURLException e) {
                    throw new RuntimeException(e);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }


                try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
                    for (String line; (line = reader.readLine()) != null; ) {
                        result.append(line);
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                return result.toString();
            });


            CompletableFuture<String> combinedResult = api1.thenCombine(api2, (result1, result2) -> result1 + ", " + result2);

            try {
                String result = combinedResult.get();
                System.out.println(result);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } catch (ExecutionException e) {
                throw new RuntimeException(e);
            }

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
        }
    }
    ```
