2. What is Selenium?
   Selenium is an open-source automated testing framework used to validate web applications across different browsers and platforms. It supports multiple programming languages like Java, C#, Python, etc. Selenium WebDriver, a component of Selenium, directly interacts with the browser and allows you to create robust, browser-based regression automation suites and tests.

3. What is Cucumber?
   Cucumber is a tool used for Behavior-Driven Development (BDD). It allows the writing of test cases in a human-readable format, which can then be executed by the tool. This approach enables collaboration between non-technical stakeholders and the development team, ensuring that software features meet business requirements.

4. What is JMeter?
   Apache JMeter is an open-source software designed for load testing and measuring performance. Originally designed for testing Web Applications, it has since expanded to other test functions. JMeter can be used to simulate a heavy load on a server, network, or object to test its strength and analyze overall performance under different load types.

5. What is the Lifecycle of JUnit?
   JUnit lifecycle includes annotated methods that run at specified times during testing:

`@BeforeClass`: Executes once before any of the test methods in the class.
`@Before`: Executes before each test method.
`@Test`: The actual test cases.
`@After`: Executes after each test method.
`@AfterClass`: Executes once after all test methods are executed.
6. Is @BeforeAll Method Should be Class-Level (Static)?
   Yes, in JUnit 5, the @BeforeAll annotation is used for static methods that run once before any test methods in the current class. It must be applied to a static method to work properly.

7. What is Mockito? What are Its Limitations?
   Mockito is a popular mocking framework for unit tests in Java. It allows you to create and configure mock objects. Using Mockito, you can effectively isolate the class under test by replacing its dependencies with mocks.

Limitations:

Cannot mock private, static, or final methods.
Cannot mock constructors.
It's not ideal for testing complex interactions between objects or actual functionality.
Alternatives/Complements:

PowerMock: Useful for mocking static, private methods, constructors, and more.
JMockit: Another alternative that offers additional mocking capabilities.
8. What is @Mock and What is @InjectMocks?
   @Mock: This annotation is used to create a mock object. It can be used instead of the manual calling of Mockito.mock().
   @InjectMocks: This annotation is used to create an instance of the class and injects the mocks that are marked with the @Mock annotations into it.
9. What is Stubbing (Define Behaviors)?
   Stubbing in Mockito refers to the process of defining the behavior of mock objects. It involves specifying what should be returned or what should happen when specific methods on the mock objects are called.

10. What is Mockito ArgumentMatchers?
    ArgumentMatchers are used in Mockito to match arguments passed to mock methods. They allow for more flexible interaction testing, as you can specify general conditions for arguments (like anyString(), anyInt()) instead of exact values.

11. What are Hamcrest Matchers?
    Hamcrest provides a library of matcher objects (also known as constraints or predicates) in Java. It allows for writing more flexible and expressive tests using a declarative style of matching rules. They are commonly used in assertions and for mock object interaction verification.

12. Do You Know @Spy? What is the Difference Between @Spy and @Mock?
    @Spy is used to create a spy instance. Spies are used when you want to partially mock an object - you want to mock certain methods and keep the original behavior of others.

Difference:

@Mock creates a complete mock. The default behavior of methods of a mocked object is to do nothing.
@Spy creates a partial mock. The default behavior of methods is to call the real implementation.
13. What is Assertion?
    Assertions are statements in test code that check whether a certain condition is true. They are used to validate the test's outcome, ensuring that the code behaves as expected.

14. If You Develop a New Feature, What Types of Tests Would You Write?
    For a new feature, various types of tests can be written:

Unit Tests: Validate individual components or functions for correctness.
Integration Tests: Ensure that different modules or services work well together.
Functional Tests: Test a particular piece of functionality in the application.
End-to-End Tests: Validate the flow of an application from start to finish.