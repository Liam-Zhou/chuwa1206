### HW47

## Q2. what is selenium?
Selenium is an open-source framework for automated testing of web applications across different browsers and platforms. 

## Q3. what is cucumber?
Cucumber is an open-source tool used for Behavior-Driven Development (BDD), which allows for the specification of application behavior in plain, descriptive language that can be understood by all stakeholders, including developers, testers, and business analysts.
```java
Feature: Login functionality

  Scenario: Successful login with valid credentials
    Given the user is on the login page
    When the user enters valid username and password
    Then the user should be directed to the dashboard page

  Scenario: Unsuccessful login with invalid credentials
    Given the user is on the login page
    When the user enters an invalid username or password
    Then the user should see an error message
```
## Q4. what is JMeter?
JMeter, short for Apache JMeter, is an open-source Java application designed primarily for performance testing and measuring the functional behavior and performance of various services, with a focus on web applications.

## Q5. What is the lifecircle of Junit?

1. Setup: This phase puts the the test infrastructure in place. JUnit provides class level setup (`@BeforeAll`) and method level setup (`@BeforeEach`). Generally, heavy objects like databse comnections are created in class level setup while lightweight objects like test objects are reset in the method level setup.
2. Test Execution: In this phase, the test execution and assertion happen. The execution result will signify a success or failure.
3. Cleanup: This phase is used to cleanup the test infrastructure setup in the first phase. Just like setup, teardown also happen at class level (`@AfterAll`) and method level (`@AfterEach`).

## Q6. Is @BeforeAll method class level(static)?
Yes, `@BeforeAll` is a class level method. 

## Q7. What is Mockito? and what is its limitations? What kind of tools can give help?
Mockito is a popular open-source Java-based mocking framework used in unit testing. It's particularly useful for tests where you need to mock or simulate the behavior of complex dependencies, such as database connections, network services, or other external systems. Mockito allows developers to create and configure mock objects that can be used to isolate the class under test, ensuring that unit tests focus solely on the class's logic and not on its dependencies.

Limitation: Mockito struggles with mocking static and private methods directly. We can use PowerMock to help.

## Q8. What is @Mock and what is @InjectMocks?
- The `@Mock` annotation is used to create a mock object for a class or an interface. Mock objects simulate the behavior of real objects. 

- The `@InjectMocks` annotation is used to create an instance of the class under test and automatically inject all the mocked dependencies annotated with `@Mock` (or created via mock() method) into it.

## Q9. What is the stubbing (define behaviors)?
Stubbing is a technique used in unit testing to replace real method calls with predefined responses (or "stubs"). This approach is particularly useful when testing a piece of code in isolation from its dependencies or external services. 
```java
import static org.mockito.Mockito.*;
public class MyTestClass {
    @Test
    public void testMethod() {
        // Create a mock instance of ExternalService
        ExternalService mockService = mock(ExternalService.class);
        
        // Stubbing: Define the behavior of the mock object
        when(mockService.getData()).thenReturn("stubbed data");

        // Now, mockService.getData() will return "stubbed data" in this test context
        assertEquals("stubbed data", mockService.getData());
      
        // You can also stub methods to throw exceptions
        when(mockService.getData()).thenThrow(new RuntimeException());
    }
}
```

## Q10. what is Mockito ArgumentMatchers
In Mockito, ArgumentMatchers are used to provide flexible argument matching when stubbing methods or verifying interactions. They allow you to specify conditions for arguments passed to methods, rather than using exact values, which can make your tests more flexible and expressive.

## Q11. what is Hamcrest Matchers
Hamcrest Matchers is a framework for writing matcher objects, allowing 'match' rules to be defined declaratively. 
```java
import org.junit.Test;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

public class HamcrestExampleTest {

    @Test
    public void testListContainsElement() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        // Using Hamcrest matcher to test if the list contains a specific element
        assertThat(numbers, hasItem(3));
    }

    @Test
    public void testString() {
        String greeting = "Hello, World!";
        // Using Hamcrest matchers for strings
        assertThat(greeting, startsWith("Hello"));
        assertThat(greeting, endsWith("World!"));
        assertThat(greeting, containsString(","));
    }

    @Test
    public void testCombiningMatchers() {
        double result = 9.5;
        // Combining matchers to create a more complex condition
        assertThat(result, allOf(greaterThan(9.0), lessThan(10.0)));
    }
}

```
## Q12. do you know @spy? what is difference between @spy and @Mock?
- @Mock: When you annotate an object with @Mock, Mockito creates a dummy implementation of the class or interface, completely replacing its behavior. By default, all methods of a mocked object do nothing and return default values (like null, 0, false, or empty collections) unless they are explicitly stubbed to behave differently (using when(...).thenReturn(...) for example).

- @Spy, on the other hand, wraps a real instance of the class, allowing you to monitor and alter its behavior while still retaining the original behavior of non-stubbed methods. This means that unless a method is explicitly stubbed to behave differently, calling a method on a spy will invoke the actual method on the real object.

## Q13. What is assertion?
An assertion is a statement in test code that checks if a specified condition is true. It's a key component of testing frameworks, allowing developers to validate the state of the application or the outcome of a test case. If an assertion fails, it indicates a bug in the application or an error in the test logic.

## Q14. If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?
1. Unit Tests: These tests focus on individual units or components of the application to ensure that each part functions correctly in isolation. 
2. Integration Tests: Integration tests assess how well different modules or services work together. The goal is to identify issues in the interaction between integrated components, such as API communication, database interactions, and data flow processes.

## Q15. Add unit test for CommentServiceImpl, the coverage should be 100%.
## Q16. write Integration tests for PostController. The tests should cover all scenarios.
 