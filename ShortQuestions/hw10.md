1. What is JPA? and what is Hibernate?

   - **JPA**: JPA use JDBC to CRUD database, and also transfer result from database to Java Entities.. JPA is focused mainly on the ORM layer. 
   - **Hibernate**: one of the most popular Java ORM frameworks in use today. It provides an implementation of the JPA specification, with a few additional features that are specific to Hibernate. Hibernate maps Java data types to SQL data types and database tables. It allows you to interact with a relational database without writing any SQL.

2. What is HikariCP? what is the benefits of connection pool?

   - **HikariCP**： is a high-performance JDBC connection pool that is widely used in Java applications. It is designed to be lightweight, fast, and efficient, with a small memory footprint and low CPU usage.
   - **benefits of connection pool**: Allowing multiple requests to share a single connection. This reduces the overhead of opening and closing connections, improving performance and scalability.

3. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.

   - @OneToMany：is an annotation used to establish a one-to-one relationship between two entities in a database

   - @ManyToOne：is used to define a many-to-one relationship between two entities. 

   - @ManyToMany：Is used to define a many-to-many relationship between two entities. 

     ```java
     @Entity
     public class Customer {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private Long id;
     
         private String name;
     
         @OneToMany(mappedBy = "customer")
         private List<Order> orders;
     
         // getters and setters
     }
     
     @Entity
     public class Order {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private Long id;
     
         private String orderNumber;
     
         @ManyToOne
         private Customer customer;
     
         // getters and setters
     }
     
     @Entity
     public class Student {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private Long id;
     
         private String name;
     
         @ManyToMany
         private List<Course> courses;
     
         // getters and setters
     }
     
     @Entity
     public class Course {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private Long id;
     
         private String name;
     
         @ManyToMany(mappedBy = "courses")
         private List<Student> students;
     
         // getters and setters
     }
     

4. What is the cascade = CascadeType.ALL, or phanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?

   - `CascadeType.ALL`, specifies that if an operation (such as persist, remove, merge, etc.) is performed on one side of the relationship, the same operation should be cascaded to the other side.
   - The `orphanRemoval` attribute is a boolean attribute that specifies whether to **remove entities that are no longer referenced by the owning entity**.
   - other CascadeType and their features：
     - `CascadeType.PERSIST`: Specifies that the persist operation should be cascaded from the parent entity to the child entity.
     - `CascadeType.MERGE`: Specifies that the merge operation should be cascaded from the parent entity to the child entity.
     - `CascadeType.REMOVE`: Specifies that the remove operation should be cascaded from the parent entity to the child entity.
     - `CascadeType.REFRESH`: Specifies that the refresh operation should be cascaded from the parent entity to the child entity.
     - `CascadeType.DETACH`: Specifies that the detach operation should be cascaded from the parent entity to the child entity.

5. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?

   - FetchType.LAZY and FetchType.EAGER are two options for loading related entities in Java Persistence API (JPA). The difference between the two is that **FetchType.LAZY loads the related entities only when they are needed**, while **FetchType.EAGER loads them immediately along with the parent entity**.
   - **In general, it is recommended to use FetchType.LAZY** for loading related entities, as it can help ==improve performance by reducing the number of database queries==. However, there are situations where **FetchType.EAGER might be more appropriate**, such as when you know that you will ==need the related entities soon after loading the parent entity==.

6. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?

   - [JPA naming convention](https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html)
   - We do not need to implement the method by ourselves, but in some case we can override naming strategy.

7. What is JPQL?

   - JPQL, or Java Persistence Query Language, is a query language defined as part of the Java Persistence API (JPA) specification. It is used to query relational databases using object-oriented syntax and is specifically designed for querying entities and their relationships in a JPA-based application.

     ```java
     TypedQuery<Person> query = entityManager.createQuery("SELECT p FROM Person p WHERE p.age > :age", Person.class);
     query.setParameter("age", 25);
     List<Person> resultList = query.getResultList();
     ```

8. What is @NamedQuery and @NamedQueries?

   - `@NamedQuery` and `@NamedQueries` are annotations in the Java Persistence API (JPA) that allow developers to define named queries for entities.
   - @NamedQuery:  is used to define a single named query for an entity.
   - @NamedQueries: used to define multiple named queries for an entity.

9. What is @Query? In which Interface we write the sql or JPQL?

   -  is used to define custom queries directly in the **repository interface**, allowing developers to execute native SQL queries or JPQL (Java Persistence Query Language) queries.

10. What is HQL and Criteria Queries?

    - HQL is a platform-independent object-oriented query language that is similar to SQL, but operates on objects, attributes, and relationships instead of tables and columns. HQL queries are defined using the Hibernate Query Language syntax and can be used to read (SELECT), as well as bulk updates (UPDATE) and deletes (DELETE).
    - Criteria Queries, on the other hand, are used to build queries programmatically using the Criteria API. Criteria Queries are type-safe and allow you to build queries without using raw SQL. Criteria Queries can be used to read (SELECT) data from a database, but cannot be used for bulk updates or deletes.

11. What is EnityManager?

    - EntityManager is a core interface in Java Persistence API (JPA) that provides an API to create, read, update, and delete entities. It is used to manage the persistence context, which is a set of managed entity instances that are associated with a particular database. The EntityManager interface provides methods for persisting, merging, removing, and refreshing entities, as well as for querying entities using JPQL or native SQL.

12. What is SessionFactory and Session?

    - SessionFactory: is a factory for creating `Session` instances in Hibernate. It is typically created once during the application startup and is thread-safe. The `SessionFactory` is responsible for configuring and managing Hibernate, including handling the mapping between Java classes and database tables.
    - Session:  represents a single-threaded unit of work with the database. It is used to perform database operations and manage the lifecycle of persistent objects (entities). 

13. What is Transaction? how to manage your transaction?

    - A transaction is a sequence of one or more operations on a database that must be executed as a single unit of work. A transaction is typically associated with a set of operations that need to be executed together, and it ensures that the database remains in a consistent state, even in the presence of failures or errors. Transactions adhere to the ACID properties
    - To manage transactions in **JPA and Hibernate**, we can use the **EntityManager or Session interfaces**, respectively. Both interfaces provide methods for beginning, committing, and rolling back transactions. Or `@Transactional` annotation is a key component in the Spring Framework's declarative transaction management.

14. What is hibernate Caching?

    - It improves the performance of database operations by reducing the need to repeatedly access the database.

15. What is the difference between first-level cache and second-level cache?

    - **First-Level Cache (Session Cache):** 
      - The first-level cache is associated with a Hibernate `Session` object.
      - It is enabled by default and is specific to the current session. When an entity is loaded or queried for the first time within a session, it is stored in the first-level cache.
      - Subsequent requests for the same entity within the same session are served directly from the cache, eliminating the need for additional database queries.
      - The first-level cache is temporary and lasts for the duration of the session.
    - **Second-Level Cache:**
      - The second-level cache is shared across multiple sessions within the same application.
      - It provides a global cache that can be used to store entities or query results.
      - The second-level cache is more persistent than the first-level cache and can survive across multiple sessions.
      - Hibernate supports various second-level cache providers, such as Ehcache, Infinispan, Hazelcast, and others.

16. How do you understand @Transactional? (https://github.com/TAIsRich/tutorialtransaction)

    - Is used to declare transactional behavior on methods or classes. It indicates that the annotated method (or methods within the annotated class) should be executed within a transactional context. 

17. what is the @configuration and @bean?

    - @configuration: 
      - The `@Configuration` annotation is used to indicate that a class declares one or more `@Bean` methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime.
      - Classes annotated with `@Configuration` are typically used to define the configuration of the Spring application context, including the declaration of beans.
    - @bean：
      - The `@Bean` annotation is used to explicitly declare a bean. A method annotated with `@Bean` produces a bean definition for the object that will be returned from that method.
      - This annotation is typically used on methods within classes annotated with `@Configuration`. The method's return type is the type of the bean, and the method body contains the logic for creating and configuring the bean.
      - Spring container manages the lifecycle of beans defined with `@Bean` and injects them into other beans or components.

18. How do you handle the exception in Spring?

    - Use the @ControllerAdvice annotation to define a global exception handler that will handle any unhandled exceptions that occur in your application.
    - Define a custom exception class for the types of exceptions that you want to handle and use Spring’s @ExceptionHandler annotation to handle those exceptions 

19. How do you do the validations in Spring? And list some validation annotaitons you know.

    - In Spring, you can perform validations using the Java Bean Validation API. To use it, you annotate domain model properties with declarative validation constraints which are then enforced by the runtime. Additionally, Spring provides support for validation through the `@Valid` annotation in the context of data binding and form submission.
    - `@NotNull`: Ensures that the annotated element is not null.
    - `@Size(min, max)`: Validates that the size of the annotated element is between the specified boundaries.
    - `@Min(value)`: Validates that the annotated element is greater than or equal to the specified minimum.
    - `@Max(value)`: Validates that the annotated element is less than or equal to the specified maximum.
    - `@NotEmpty`: Ensures that the annotated element is not null and not empty (for collections, arrays, or strings).
    - `@NotBlank`: Ensures that the annotated element is not null and contains at least one non-whitespace character.
    - `@Email`: Validates that the annotated element is a valid email address.
    - `@Past`: Validates that the annotated date is in the past.
    - `@Future`: Validates that the annotated date is in the future.

20. What is the actuator, list some endpoints it provides?

    - Spring Boot Actuator is a set of production-ready features that help you monitor and manage your application. It provides several built-in endpoints that expose information about your application's health, metrics, environment, and more. These endpoints are useful for monitoring and managing your application in a production environment.
    - **Health Endpoint (`/actuator/health`):**
      - Provides information about the health of the application.
      - Typically returns a JSON response indicating whether the application is UP or DOWN, along with additional details.
    - **Info Endpoint (`/actuator/info`):**
      - Exposes arbitrary application information that you can define.
      - Useful for providing additional metadata about the application.
    - **Metrics Endpoint (`/actuator/metrics`):**
      - Exposes a wide range of application metrics.
      - You can view metrics such as memory usage, garbage collection stats, thread usage, and more.
    - **Environment Endpoint (`/actuator/env`):**
      - Displays information about the application's environment properties.
      - Useful for inspecting the configuration properties of the application.
    - **Beans Endpoint (`/actuator/beans`):**
      - Provides a complete list of all Spring beans in the application.
      - Useful for understanding the beans defined in the application context.
    - **Mappings Endpoint (`/actuator/mappings`):**
      - Shows a list of all the request mappings in the application.
      - Useful for understanding how URLs map to controllers and methods.
    - **Shutdown Endpoint (`/actuator/shutdown`):**
      - Allows you to shut down the application gracefully.
      - Note: Ensure that this endpoint is secured properly in a production environment.
    - **Trace Endpoint (`/actuator/trace`):**
      - Provides a trace of recent HTTP requests handled by the application.
      - Useful for debugging and understanding the flow of requests.