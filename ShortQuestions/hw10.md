### 2.what is the @configuration and @bean?

>The `@Configuration` annotation is used at the class level to indicate that the class contains bean definitions and configuration information for the Spring application context.
>
>The `@Bean` annotation is used at the method level within a `@Configuration` class. It signals that the method produces a bean to be managed by the Spring container.

### 3.How do you handle the exception in Spring?

```java

//Use @ControllerAdvice to define global exception handlers across all controllers. 
@ControllerAdvice
public class GlobalExceptionHandler {
	  //Annotate methods with @ExceptionHandler to handle exceptions 				at the controller level. 
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                             .body("An internal server error occurred");
    }
}

```

### 4. How do you do the validations in Spring? And list some validation annotaitons you know.

> Use the `@Validated` annotation at the class level to enable validation on a Spring bean.
>
> Use the `@Valid` annotation at the method parameter level to trigger validation on that parameter.
>
> - `@NotNull`: Checks that the annotated element is not `null`.
> - `@Size(min, max)`: Checks that the annotated element size is between the specified boundaries.
> - `@Min(value)`: Checks that the annotated element is a number whose value is higher or equal to the specified minimum.
> - `@Max(value)`: Checks that the annotated element is a number whose value is lower or equal to the specified maximum.
> - `@NotBlank`: Checks that the annotated string is not null or empty.
> - `@Email`: Checks that the annotated string is a valid email address.



### 5. What is the actuator, list some endpoints it provides?

> Spring Boot Actuator is a set of production-ready features that help you monitor and manage your Spring Boot application. It provides several built-in endpoints that expose information about your application's health, metrics, environment, and more. 
>
> **`/actuator/health`** **`/actuator/env`**
>
> **`/actuator/info`** **`/actuator/beans`**
>
> **`/actuator/metrics`** **`/actuator/trace`**

### 2. What is Spring and Springboot? What is the benfits of using Srpingboot?

> SpringBoot makes it easy to work with Spring framework. When using Spring framework, we have to take care of all the configuration ourselves like, for making a web application, DispatcherServlet, ViewResolver etc configurations are needed. SpringBoot solves this problem through a combination of Auto Configuration and Starter projects.

### 3. What is IOC and What is DI?

>Passing the control of objects to Spring framework, this is called Inversion of Control (IOC) and Dependency injection is one of the principles that enforce IOC.

### 4. What is @CompnonentScan?

> `@ComponentScan` is an annotation in Spring Framework used for automatic discovery and registration of Spring components (such as beans, services, and controllers) during the component scanning process. 
>
> When you use `@ComponentScan` annotation, Spring scans the specified base packages and their sub-packages for classes annotated with stereotypes like `@Component`, `@Service`, `@Repository`, and `@Controller`. It then registers these classes as Spring beans in the application context.

### 5. How to define which package spring need to scan in xml and annotaiton?

```java
//in xml
<context:component-scan base-package="com.example.package" />
//annotation
@Configuration
@ComponentScan(basePackages = "com.example.package")
public class AppConfig {
    // other configuration settings or bean definitions if needed
}
  
```

### 6.What is @SpringbootApplication?

>@SpringBootApplication is a combination of 3 different annotations:
>@Configuration: This annotation marks a class as a Configuration class in Java-based configuration, it allows to register extra beans in the context or import additional configuration classes
>@ComponentScan: to enable component scanning
>@EnableAutoConfiguration: to enable Spring Bootâ€™s auto-configuration feature
>These 3 annotations are frequently used together, so SpringBoot designers bundled them into one single @SpringBootApplication, now instead of 3 annotations you just need to specify only one annotation on the Main class.

### 7. How many ways wo can define a bean?

> - **XML Configuration:**
>
>   <bean id="myBean" class="com.example.MyBean" />
>
> - **Annotation-based Configuration**: Use annotations such as `@Component`, `@Service`, `@Repository`, or `@Controller` to mark classes as beans.
>
> - @Configuration and @Bean

### 8.  What is default bean name for @Component and @Bean?

>When you use `@Component` annotation without specifying a name, the default bean name is the uncapitalized non-qualified class name. 
>
>When you use `@Bean` annotation without specifying a name in a Java configuration class, the default bean name is the name of the `@Bean` method.

### 9. What is the difference between @component and @service,@repository?

>`@Service`, and `@Repository` are specializations of the `@Component` annotation, each intended for a specific type of class. While all three annotations serve as a way to indicate that a class is a Spring bean, they convey different semantics about the role or purpose of the bean.

### 10. How many annotaitons we can use to inject the bean?

>**`@Autowired`**
>
>**`@Qualifier`**
>
>**`@Resource`**

### 11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?

>Constructor Injection(better)
>Setter Injection
>Field Injection
>
> **Immutability**: Constructor injection allows you to create immutable objects, 
>where the object's state does not change after it is created. Immutable objects 
>are easier to understand and maintain because they do not have unexpected 
>state changes. Field injection cannot provide immutability, as it requires setting 
>dependencies after the object is created.
>**Explicit Dependencies**: Constructor injection requires all dependencies to be explicitly declared in the constructor. This makes dependencies easier to 
>understand and helps ensure the object always has a valid state when it is 
>created. In contrast, field injection may lead to dependencies being unsatisfied 
>at runtime, as they might be less obvious in the class definition.
>**Test-Friendliness**: Constructor injection makes it easier to provide alternative 
>implementations (e.g., using test doubles) in unit tests. Simply pass the 
>alternative implementations through the constructor to set up dependencies for a specific test case. In contrast, field injection might require using reflection or 
>other methods to change private fields, which can make test code more complex.
>
>**Avoid Circular Dependencies**: Constructor injection helps identify and resolve 
>circular dependency issues. When using constructor injection, the Spring 
>container automatically detects circular dependencies at startup and throws an 
>exception. However, when using field injection, you may encounter hard-to-
>diagnose issues, as circular dependencies can lead to runtime errors.
>**Compatibility with Java Records**: Record types, introduced in Java 14 and officially available since Java 16, are immutable and require constructors to set fields. Constructor injection is naturally compatible with record types, while field injection is not.