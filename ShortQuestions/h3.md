# Q2
- `Checked exception`: Those who call a method must know about the exception so that
    they can handle properly checked by the compiler at compile time e.g. IOException, SQLException, ClassNotFoundException
- `Unchecked exception`: also known as runtime exceptions. Those may happen everywhere (very common). Adding it to the method declaration will reduce the program clarity.
checked by the JVM at run time e.g. ArrayIndexOutOfBoundsException, NullPointerException
# Q3
- In Java, a try block can be associated with at most one finally block.
# Q4
Finally block will return the value.
# Q5
- Checked exception:checked by the compiler at compile time. e.g. IOException, SQLException, ClassNotFoundException
-  Unchecked exception: also known as runtime exceptions
# Q6
  - `throw`:The throw keyword is used to explicitly throw an exception within a program. It is used in the context of the try-catch block to raise a specific exception manually.
     You use throw followed by an instance of Throwable (usually an exception object)
  - `throws`:The throws keyword is used in the method signature to declare that a method may throw certain types of exceptions. It indicates that the method doesn't handle the exceptions itself but expects the calling code to handle them.
Multiple exceptions can be declared using a comma-separated list

# Q7 Run the below three pieces codes, Noticed the printed exceptions. why do we put the Null/Runtime exception before Exception ?
if you put NullPointerException before RuntimeException and Exception, the NullPointerException catch block would handle the exception, and the other catch blocks would be skipped.

# Q7 What is optional? why do you use it? write an optional example.
- Optional is a container object used to contain not-null objects. Optional object is used to
  represent null with absent value.
```
     public static void main(String[] args) {
        Optional<String> optionalValue = Optional.of("Hello, World!");

        if (optionalValue.isPresent()) {
            System.out.println("Value is present: " + optionalValue.get());
        } else {
            System.out.println("Value is absent.");
        }
        Optional<String> optionalNullValue = Optional.ofNullable(null);

        String result = optionalNullValue.orElse("Default Value");
        System.out.println("Result: " + result);

        optionalValue.ifPresent(val -> System.out.println("Length: " + val.length()));
    }
```
# Q8
The primary purpose of the finally block is to perform cleanup operations, release resources, or execute any code that should always be run, regardless of the program flow.

# Q10
- Creational Design Patterns:

- `Singleton Pattern`
- `Factory Method Pattern`
- `Abstract Factory Pattern`

- Structural Design Patterns:

- `Adapter Pattern`
- `Decorator Pattern`
- `Facade Pattern`
- `Proxy Pattern`

- Behavioral Design Patterns:

- `Observer Pattern`
- `Strategy Pattern`
- `Command Pattern`
- `State Pattern`
# 11
  - `Single Responsibility Principle (SRP)`:A class should have only one reason to change, meaning that a class should have only one responsibility.
  Each class or module should have a single responsibility or job, and if there's more than one reason for it to change, the class should be split.
  - `Open/Closed Principle (OCP)`:Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.
  You should be able to extend the behavior of a system without modifying its existing code.
  This is often achieved through the use of abstractions (interfaces, abstract classes) and polymorphism.
  - `Liskov Substitution Principle (LSP)`:Subtypes must be substitutable for their base types without altering the correctness of the program.
  Derived classes should extend the functionality of the base classes without changing their behavior.
  - `Dependency Inversion Principle (DIP)`:High-level modules should not depend on low-level modules. Both should depend on abstractions.
  Abstractions should not depend on details. Details should depend on abstractions.
  Dependency inversion is often achieved through the use of dependency injection (constructor injection, method injection, or setter injection).

# 12
- `Egaer Initialization`: 
 
    ```
   public class EagerSingleton {
    private static final EagerSingleton instance = new EagerSingleton();

    private EagerSingleton() {
        // private constructor to prevent instantiation
    }

    public static EagerSingleton getInstance() {
        return instance;
    }
} 
    ```
- `Lazy Initializaion`:
    ```
   public class LazySingleton {
    private static volatile LazySingleton instance;

    private LazySingleton() {
        // private constructor to prevent instantiation
    }

    public static LazySingleton getInstance() {
        if (instance == null) {
            synchronized (LazySingleton.class) {
                if (instance == null) {
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}
  
   ```


# 13
- Open/Closed principle means classes should be open for extension but closed for modification. Unless you are debugging the current class, it is not advisable to modify the class to add more functionalities because modifying the class can potentially introduce new bugs. Instead, you should create a new class to extend the previous class.

# 14
    3. It means if a method is present in class A, it should also be present in class B so that the object of
        type B could substitute object of type A.
