2. Key components and tools of microservices architecture include:  
(1) Service Discovery: Mechanisms for services to find and communicate with each other, with tools like Eureka, Zuul.  
(2) API Gateway: Acts as the single entry point to the system, providing routing, authentication, monitoring, etc.  
(3) Containerization: Packaging, deploying, and scaling services using Docker or Kubernetes.  
   (4) Configuration Management: External storage for managing service configurations, with tools like Spring Cloud Config, Consul Config.  
   (5) Load Balancing: Distribution client requests across services, with Hystrix being a popular choice.  
   (6) Circuit Breaker: Prevents failure from spreading across services, with Hystrix being a popular choice.  
   (7) Tracing and Monitoring: Monitors calls and performance between services, with tools like Prometheus, Zipkin.  
   (8) Message Queue: Supports asynchronous communication between services, with RabbitMQ, Kafka. 
3. Resilience Patterns are design patterns help applications to respond gracefully to unexpected failures and maintain a 
level of operational performance. There patterns are crucial in distributed systems, like microservices, where different 
parts of the application are deployed independently. (帮助程序更好的相应意外失败并保持一定的性能) Resilience pattern include:   
   (1) Retry: Automatically retrying an operation that has failed, hoping it will succeed in subsequent attempts.  
   (2) Circuit Breaker: Preventing a cascade of failures by temporarily blocking failing operations. 阻止失败操作，防止失败蔓延。
   (3) Timeout: Limiting the time waiting for an operation to complete to avoid system hang.
   (4) Fallback: Providing an alternative solution when a operation fails.
   (5) Bulkhead: Isolating elements of a application into pools so that if one fails, the others continue to function.
   (6) Rate Limiting: Controlling the number of requests to a service within a given timeframe to prevent overload. 

Circuit Breaker: 断路器  
The circuit breaker pattern is a design pattern used to prevent a system from performing operations that are likely 
to fail. The pattern is named after an electrical circuit breaker that cut off electric flow when a system is overloaded 
to prevent damage. 

When the number of failures crosses a threshold, the circuit breaker trips, and for the duration of a timeout period, 
all attempts to invoke the operation are automatically returned with an error.  失败超过阈值，断路器触发，暂停一段时间，就自动返回错误。
After the timeout expires, the circuit breaker allows a limited number of test requests to pass through. If these requests 
succeed, the circuit breaker resets and begins allowing normal operation. If they fail, the timeout period begins again.
(超过后，断路器允许有限数量的测试请求通过。如果请求成功，断路器重置并开始允许正常操作。如果失败，超时期重新开始。)
4. Benefit and Drawbacks of Microservice  
self-contained, and independent deployment module.   独立部署
Independently managed services.   独立管理
In order to improve performance, the demand service can be deployed on multiple servers.  为了性能可以部署在多台服务器上
It is easier to test and has fewer dependencies.  容易测试并依赖少
A greater degree of scalability and agility.   更高程度的可扩展性和敏捷性
Simplicity in debugging & maintenance   调试和维护简单

Due to the complexity of the architecture, testing and monitoring are more difficult.   架构复杂，测试监控难
Lacks the proper corporate culture for it to work.   缺乏企业文化来发挥作用
6. Service Discover is used to allow services to dynamically discover and communicate with each other. Service discovery 
can be implemented using two main approaches: client-side discovery and server-side discovery.   

Client-Side Discovery: In this approach, the client service is responsible for determining the network locations of 
available service instance and balancing the load between them. It typically queries a service registry, which is a database 
of available service instances. The client the uses a load-balancing algorithm to select an instance and makes a direct call 
to the chosen service instance.
在这种方法中，客户端服务负责确定可用服务实例的网络位置，并在它们之间平衡负载。它通常查询一个服务注册表，这是一个可用服务实例的数据库。然后客
户端使用负载均衡算法选择一个实例，并直接调用选定的服务实例。  
Sever-Side Discovery: 
In server-side discovery, the client service makes a request to a service, which is responsible for directing the request 
to an available service instance. This approach abstracts the discovery logic from the client, simplifying the client's 
implementation. The service gateway or load balancer queries the service registry and directs the client's request to an appropriate 
service instance.  
在服务器端发现中，客户端服务向一个服务（通常称为服务网关或负载均衡器）发出请求，该服务负责将请求定向到一个可用的服务实例。这种方法将发现逻辑从
客户端中抽象出来，简化了客户端的实现。服务网关或负载均衡器查询服务注册表，并将客户端的请求定向到适当的服务实例。  

7. main components in Kafka:  
   (1) Producer: producers publish data to topic
   (2) Consumer: Consumer read data from topic
   (3) Broker: Broker is a composed of multiple servers.
   (4) Topic: A topic is a category or feed to which records are published by producers.
   (5) Partition: Topic are split into partitions. This allow data to be distributed across cluster.
   (6) ZooKeeper: ZooKeeper is used to managing and coordinating Kafka brokers.
   (7) Consumer Group: is a set of consumer processes that are subscribing to a specific topic. 
8. A `partition` is a physical segmentation of a topic. Each topic can be divided into multiple partitions, where each 
partition is an ordered, immutable sequence of message records known as a commit. 
9. ZooKeeper is a distributed service used for coordinating and managing various operations within a Kafka cluster. 
ZooKeeper provides centralized services for maintaining configuration information, naming, providing distributed synchronization,
and providing group services.   
Main uses:  
   (1) Broker registration: Kafka Brokers register themselves with ZooKeeper at startup. ZooKeeper maintains a list of all active 
Brokers in the cluster, which clients and other Brokers can use to find available Brokers.
   Kafka的Broker启动时会在ZooKeeper中注册自己。ZooKeeper维护着集群中所有活跃Broker的列表，客户端和其他Broker可以通过这个列表找到可用的Broker。  
   (2) Leader Election: In Kafka's partition replication mechanism, each partition is composed of one leader replica and 
multiple follower replicas. ZooKeeper is responsible for coordinating the leader election process among these replicas.
   在Kafka的分区副本机制中，每个分区由一个领导者副本和多个追随者副本组成。ZooKeeper负责协调这些副本之间的领导者选举过程。  
   (3) Cluster Metadata Management: ZooKeeper stores metadata information about Topics, partitions, replicas, etc. This 
includes information on the leaders of each partition, the location of partition replicas, and more.
   ZooKeeper存储了关于Topic、分区、副本等的元数据信息。这包括每个分区的领导者信息，分区副本的位置等  
   (4) Configuration Management:  Configuration information for the Kafka cluster is stored in ZooKeeper, including Topic configurations, quota limits, etc.
   Kafka集群的配置信息存储在ZooKeeper中，包括Topic配置、配额限制等。  
   (5) Consumer Group Coordination: In older versions of Kafka, ZooKeeper was also used to manage consumer group 
membership and offset management (although in the latest versions of Kafka, these functions have been moved to Kafka's
own internal management).  在旧版本的Kafka中，ZooKeeper还用于管理消费者组的成员资格和偏移量管理（尽管在最新版本的Kafka中，这些功能已经转移到Kafka自身的内部管理）。  
10. Since with Kafka 2.8.0, the KRaft mode was introduced, allowing Kafka to run without ZooKeeper. This marks a significant 
step towards Kafka operating independently of ZooKeeper.
11. Leader and Follower refers to the role assignment of partition replicas.   
`Leader:`  
Leader replica of each partition is responsible for handling all read and write requests for that partition.   
Client interact only with the leader replica to ensure data consistency.   
The leader replica is responsible for updating the follower replicas, ensuring all replicas are synchronized.   
`Follower:`   
Follower replicas do not directly serve client requests. Their primary task is to replicate data from the leader replica.   
A follower replica is considered "in-sync" when its data is fully synchronized with the leader's data.   
If the leader replica fails, an in-sync follower replica will be elected as the new leader.   
`Leader Election:`  
Leader election occurs when the current leader replica becomes unresponsive due a failure.   
Kafka coordinates leader elections through ZooKeeper.   
The election process ensures that at any time, each partition has only one leader, and all in-sync followers are ready 
to take over the leadership role. 
12. Because topic replication can make sure even if a broker fails, the data can be recovered from other replicas.   
ISR means in-sync replicas which refers to the set of replica that are up-to-date with leader and can be considered for 
electing a nre leader if the current leader fails. 
13. Consumer group is a set of consumers working together to consume data from one or more topics. Each consumer(in the same group)
reads from a unique set of partitions. 组内的每个消费者从唯一的分区集读取数据，
14. To start a Kafka server, follow these steps:

Start ZooKeeper server: `./bin/zookeeper-server-start.sh config/zookeeper.properties`  
Start Kafka server: `./bin/kafka-server-start.sh config/server.properties`
15. Kafka real world example: (1) Stream Processing (2) Messaging (3) Log Aggregation
16. Partitioning key is used to determine how data is distributed across partitions within a topic. When a message is produced, 
the partitioning key is used by the producer to decide which partition the message should be sent to. 当生产者发送消息时，分区键被用来决定消息应该发送到哪个分区。
17. The purpose of partition:  

(1) Scale Horizontally: Partitions allow a topic to be scaled by distributing data across multiple brokers. 通过在多个代理之间分配数据来扩展主题。
(2)Increase Parallelism: Multiple consumers can read from different partitions simultaneously, increasing throughput. 多个消费者可以同时从不同的分区读取数据，提高吞吐量。
(3) Ensure Ordering: Within a partition, messages are ordered by their arrival time, enabling ordered processing in consumer applications.在一个分区内，消息按到达时间排序，使消费者应用能够按顺序处理。
(4) Fault Tolerance: Replication partitions across brokers enhances data redundancy and fault  tolerance. 在代理之间复制分区增加了数据冗余和容错能力。


18. The difference between Kafka and RabbitMQ:  


(1) Use Case:   
RabbitMQ is primarily used for requiring complex routing, message queueing, and delivery confirmations. It excels in 
scenarios where the requirement is for message acknowledgement and high reliability in message delivery.   
Kafka is design for high-throughput, persistent, and scalable streaming data scenarios. It is ideal for log aggregation, real-time analytics, and event sourcing.
(2) Architecture:   
RabbitMQ is based on the AMQP(Advanced Message Queuing Protocol). Kafka uses a distributed commit log architecture.
(3) Performance: RabbitMQ may struggle with very high throughput requirements compared to Kafka.
(4) Data Durability and Retention:   
RabbitMQ often use for transient messaging where message are not stored for long periods. It can be configured for durability, but this is not primary use case. 
kafka is designed to hold large amounts of data for a configurable period, making it suitable for scenarios where data needs to be reprocessed or analyzed.
(5) Consumer Management: RabbitMQ: Manages consumer messages with a push model, actively delivering messages to consumers based on the consumer's capacity.

19. There are several key guarantees:
    (1) Message are appended in order: Messages sent by a producer to specific topic partition are appended in the order they are sent.
    (2) At-least-once delivery: Kafka can be configured to ensure that messages are delivered at lease once to consumers, ensuring no data loss.
    (3) Exactly-once delivery: Kafka supports exactly-once delivery semantics in certain configurations, ensuring that messages are neither lost nor seen more than once.
    (4) Replication for fault tolerance: Kafka replicates data across multiple brokers to ensure that data is not lost if a broker fails.
    (5) Consumer offset management: Kafka tracks the read status of each message for consumers, allowing consumers to resume from the last message read, even after failures. 
20. Unbalanced cluster means a situation where the distribution fo partitions, leaders, or data across the brokers in the cluster is uneven. Kafka中的不平衡集群指的是集群中分区、领导者或数据在代理间分布不均的情况。

To solve this: (1) Reassign Partitions: Use Kafka partition reassignment tool to redistribute partitions and data more evenly across the brokers.
(2) Monitor and Adjust: Continuously monitor the cluster's performance, partition distribution, and broker load. Adjustments may need to be make periodically to maintain balance.
(3) Use rack Awareness: Configure rack awareness to ensure that replicas of a partition are spread across different racks or data centers, improving fault tolerance and load distribution. 
25. Offset is a unique identifier of each record within a partition. It denotes the position of a message within that partition. 