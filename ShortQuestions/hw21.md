## 										Homework21



### 2.checked exception and unchecked exception

checked exceptions are exceptions checked at compile time. Compilers must explicitly handle these exceptions. If a method may throw a checked exception, then programmers  either need to use a try-catch block to handle it, or should declare a thows key word in the method signature. Example: FileNotFoundException, IOException

unchecked exceptions (runtime exception) will not be checked at complie time. Compilers don't require these exceptions to be caught or declared in the method signature. Example: NullPointerException, ArithmeticException.

### 3.multiple final blocks?

Apparently, only one finally block can be associated with a try-catch block. But for the whole program, it's fine to have any final blocks.

### 4.when both catch and finally return, which value?

when both catch and finally returns a value, the latter one is the final result, But if finally don't have a return, then the final result is the value returned by catch block.

### 5.Runtime/unchecked exception, Compile/Checked Exception

Just As Question 2. Runtime exceptions need to be explicit handled to pass the complier test, either by try-catch block or by a throws key word at the method signature. Compile Exception doesn't have such requirements. It's okay not to handle them.

### 6.throw, throws

`throw` is used in a method body to throw an exception and might be caught by a try catch block.

`throws` is used in a method signature to declare possible exceptions a method might throw, and informs that the method need to handle or propagate these exceptions.

### 7.

![image-20231214163434449](/Users/yixingshen/Library/Application Support/typora-user-images/image-20231214163434449.png)

![image-20231214163519100](/Users/yixingshen/Library/Application Support/typora-user-images/image-20231214163519100.png)

![image-20231214163552811](/Users/yixingshen/Library/Application Support/typora-user-images/image-20231214163552811.png)

Because Null/Runtime exception's scope is smaller than Exception. Putting it first can help locate exceptions precisely. If it doesn't belong to Null/Runtime exception, we finally treat it as a common Exception.

### 8.Optional? Why use it? Write an example

Optional is an container object introduced after Java 8. It can help avoid NullPointerException and make code more readable (also reduce code lines) by explicitly handling the cases of absent values.

```Java
import java.util.HashMap;
import java.util.Optional;

public class Main {
    public static HashMap<String,String>map;

    public static void main(String[] args) {
        map=new HashMap<>();
        map.put("a","1");
        map.put("b","2");
        String r1=Optional.ofNullable(map.get("a")).orElse("NULL");
        String r2=Optional.ofNullable(map.get("c")).orElse("NULL");
        System.out.println(r1);
        System.out.println(r2);
    }
}
```

### 9.why finally always be executed

The `finally` block ensures that important code is executed even if an exception occurs. This is crucial for avoiding resource leaks, which can lead to performance issues or other bugs.

### 11.What are the types of design patterns in Java?

1. **Creational Patterns**: These patterns are all about class instantiation or object creation. They abstract the instantiation process and help make a system independent of how its objects are created, composed, and represented.
2. **Structural Patterns**: These patterns are concerned with how classes and objects are composed to form larger structures. Structural patterns simplify the structure by identifying the relationships.
3. **Behavioral Patterns**: These patterns are all about class's objects communication. Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects.
4. **Concurrency Patterns**: These patterns deal with the multi-threaded programming paradigm. They help solve problems of multi-threading like synchronization, deadlocks, etc.

### 12.SOLID

The SOLID principles are a set of five design principles in object-oriented programming that help developers design systems that are easy to maintain, extend, and understand. 

### 13.how to achieve thread-safe singleton patterns

Eager Initialization，Synchronized Accessor，Double-Checked Locking (DCL)， Static Inner Class，Enum Singleton

### 14.OCP

Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.

This principle suggests that you should be able to add new functionality to a class or module without changing the existing code. It encourages the use of interfaces or abstract classes to allow the behavior of modules to be extended.

### 15.

1