1. [Practice collection](https://github.com/B1gO/chuwa-eij-tutorial/tree/main/02-java-core/src/main/java/com/chuwa/exercise/collection)
2. What is the checked exception and unchecked exception in Java, could you give one example?

   - Checked exception: exceptions that are checked in compile time

     - IOException

   - Unchecked exception: exception that are checked in run time

     - NullPointerException

3. Can there be multiple finally blocks?

   No

4. When both catch and finally return values, what will be the final result?

   Return value from finally block.

5. What is **Runtime/unchecked exception**? what is Compile/Checked Exception?

   - Runtime/unchecked exception
     - exception that is checked during run time
     - It's up to programmers to capture it
   - Compile/Checked Exception
     - exception that is checked during compile time
     - compiler will enforce it (errors shown on IDE)

6. What is the difference between **throw** and **throws**?

   - throw
     - throw exceptions inside of try catch block
     - followed by exception class instance
   - throws
     - method signature that shows what kinds of exceptions will be thrown from the method
     - followed by exception class name

7. Run the below three pieces codes, Noticed the printed exceptions. why do we put the Null/Runtime exception before Exception ?

   Should put narrower exceptions before broader exceptions

```
public class Main {
    public static void main(String[] args) {
        int a = 0;
        int b = 3;
        String s = null;
        try {
            System.out.println(b / a);
            System.out.println(s.equals("aa"));
            throw new RuntimeException();
        } catch (ArithmeticException e) {
            e.printStackTrace();
        } catch (NullPointerException e) {
            e.printStackTrace();
        } catch (RuntimeException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.getMessage();
        }
        System.out.println("End ...");
    }
}
```

```
java.lang.ArithmeticException: / by zero
	at Main.main(Main.java:7)
End ...
```

```
public class Main {
    public static void main(String[] args) {
    int a = 0;
    int b = 3;
    String s = null;
    try {
        // System.out.println(b / a);
        System.out.println(s.equals("aa"));
        throw new RuntimeException();
    } catch (ArithmeticException e) {
        e.printStackTrace();
    } catch (NullPointerException e) {
        e.printStackTrace();
    } catch (RuntimeException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.getMessage();
    }
    System.out.println("End ...");
    }
}
```

```
java.lang.NullPointerException: Cannot invoke "String.equals(Object)" because "s" is null
	at Main.main(Main.java:8)
End ...
```

```
public class Main {
    public static void main(String[] args) {
    int a = 0;
    int b = 3;
    String s = null;
    try {
        // System.out.println(b / a);
        // System.out.println(s.equals("aa"));
        throw new RuntimeException();
    } catch (ArithmeticException e) {
        e.printStackTrace();
    } catch (NullPointerException e) {
        e.printStackTrace();
    } catch (RuntimeException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.getMessage();
    }
    System.out.println("End ...");
    }
}
```

```
java.lang.RuntimeException
	at Main.main(Main.java:9)
End ...
```

8. What is **optional**? why do you use it? write an optional example.

   Optional is a container that can store values of type T and null. We use it to prevent explicitly checking null.

```
Integer value = null;
Optional<Integer> a = Optional.ofNullable(value);
System.out.println(a.isPresent()); // false
value = a.orElse(new Integer(0)); // value = 0
```

9. Why finally always be executed ?

   To ensure finally block is executed even if there is an unexpected exception

10. What are the types of design patterns in Java ?

    - Builder Pattern
    - Structural Pattern
    - Behavioral Pattern

11. What are the **SOLID** Principles ?

    - **S**ingle-responsibility Principle
    - **O**pen-closed Principle
    - **L**iskov Substitution Principle
    - **I**nterface Segregation Principle
    - **D**ependency Inversion Principle

12. How can you achieve thread-safe singleton patterns in Java ?

    Use a static inner class to hold the singleton instance

13. What do you understand by the Open-Closed Principle (OCP) ?

    Classes should be open for extension but closed for modification.

14. Liskovâ€™s substitution principle states that if class B is a subtype of class A, then object of type A may be
    substituted with any object of type B. What does this actually mean? (from OA ) choose your answer. (3)
    1. It mean that if the object of type A can do something, the object of type B could also be able to
       perform the same thing
    2. It means that all the objects of type A could execute all the methods present in its subtype B
    3. It means if a method is present in class A, it should also be present in class B so that the object of
       type B could substitute object of type A.
    4. It means that for the class B to inherit class A, objects of type B and objects of type A must be same.
15. Watch the design pattern video, and type the code, submit it to **MavenProject** folder\
    [Singleton](https://www.bilibili.com/video/BV1Np4y1z7BU?p=22)\
    [Factory](https://www.bilibili.com/video/BV1Np4y1z7BU?p=35&vd_source=310561eab1216a27f7accf859bf7f6d9)\
    [Builder](https://www.bilibili.com/video/BV1Np4y1z7BU?p=50&vd_source=310561eab1216a27f7accf859bf7f6d9)\
    [Publisher_Subscriber](https://www.bilibili.com/video/BV1Np4y1z7BU?p=114&vd_source=310561eab1216a27f7accf859bf7f6d9)
