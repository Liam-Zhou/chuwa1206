1.  annotaitons.md has been created.
2.  How do you do the debug?
    - Read error log.
    - Read code line by line and comments, try to understand the Project Architecture and dataflow.
    - set break point and run the code in debug mode.
    - Look into the function causes error, and try to fix the problem.
3.  What is DTO, VO, Payload, DO, model?
    - DTO(Data Transfer Object): DTO is a design pattern used to transfer data between software application subsystems, often between the data access layer, service layer, and presentation layer.
    - VO(Value Object): VO is a design pattern similar to DTO, but it represents an object that contains data and possibly some associated business logic.
    - Payload: Payload refers to the data transmitted over a network or between different parts of a software system. In the context of Spring Boot and RESTful APIs, the payload usually refers to the data sent in the request body (e.g., JSON or XML) or the data returned in the response body.
    - DO(Domain Object): DO represents objects that model the entities and concepts within the domain of the application.
    - Model: Model objects often represent the state of the application and are used to transfer data between different layers of the application, including the presentation layer, service layer, and data access layer.
4.  What is @JsonProperty("description_yyds")

    @JsonProperty is an annotation provided by the Jackson library, which is used for JSON processing in Java. It is used to annotate fields or methods within a Java class to specify the name of the property when it is serialized to JSON or deserialized from JSON.

    **Serialization:** When Java objects are serialized to JSON, the names of the Java fields are used as the property names in the JSON output by **default**. If you want to use a different name in the JSON output, you can annotate the field with `@JsonProperty` and specify the desired name.

    **Deserialization:** When JSON data is deserialized into Java objects, Jackson maps the JSON properties to Java fields based on their names. If the JSON property name differs from the Java field name, you can use `@JsonProperty` to specify the name of the JSON property to be mapped to the Java field.

5.  Do you know what is jackson?

    ```
    <dependency>
         <groupId>com.fasterxml.jackson.core</groupId>
         <artifactId>jackson-databind</artifactId>
         <version>2.13.3</version>
         <scope>compile</scope>
     </dependency>
    ```

    Jackson provides functionalities to serialize Java objects into JSON format and deserialize JSON data into Java objects. Specifically, by including this dependency, it provides the ability to convert JSON data to and from Java objects (POJOs).

6.  What is spring-boot-stater?

    `spring-boot-starter` is a set of dependency management "starters" provided by the Spring Boot framework. These starters are pre-configured collections of dependencies that enable developers to quickly set up and bootstrap Spring Boot applications with specific functionality or for specific purposes, such as **web applications, data access, security, testing**, etc. They help simplify the **configuration** and **setup** process by providing a cohesive set of dependencies and configurations, allowing developers to focus on building their application logic rather than managing dependencies and configurations.

    What dependecies in the below starter? do you know any starters?

    ```
     <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-web</artifactId>
     </dependency>
    ```

    By including spring-boot-starter-web in your Spring Boot project's dependencies, you get all the necessary components and configurations to develop web applications using Spring Boot without having to manually configure each component. This allows web developer to **focus on writing your application logic** and** building your web endpoints** rather than worrying about the underlying infrastructure and dependencies.
    Here's what spring-boot-starter-web typically provides:

    - Spring MVC (Model-View-Controller)
    - Embedded Servlet Container
    - Spring Web
    - Spring Boot Autoconfiguration

7.  Do you know @RequestMapping(value = "/users", method = RequestMethod.POST)? could you list CRUD by this style?

    The `@RequestMapping` annotation with `method = RequestMethod.POST` maps incoming POST requests to specific controller methods. When combined with the `value` attribute, it specifies the URL path for which the method should be invoked.

    Create (POST):

    ```
     @PostMapping("/users")
     public ResponseEntity<User> createUser(@RequestBody User user) {
         // Logic to create a new user
         return ResponseEntity.ok(createdUser);
     }
    ```

    Read (GET):

    ```
     @GetMapping("/users/{userId}")
     public ResponseEntity<User> getUser(@PathVariable Long userId) {
         // Logic to fetch a user by userId
         return ResponseEntity.ok(user);
     }
    ```

    Update (PUT or PATCH):

    ```
    @PutMapping("/users/{userId}")
    public ResponseEntity<User> updateUser(@PathVariable Long userId, @RequestBody User user) {
        // Logic to update the user identified by userId
        return ResponseEntity.ok(updatedUser);
    }
    ```

    Delete (DELETE):

    ```
    @DeleteMapping("/users/{userId}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long userId) {
        // Logic to delete the user identified by userId
        return ResponseEntity.noContent().build();
    }
    ```

8.  What is ResponseEntity? Why do we need it?

    `ResponseEntity` is a class provided by Spring Framework that represents the entire HTTP response, including status code, headers, and body. It is commonly used to customize the HTTP response returned from Spring MVC controller methods.

    The reason we need to:

    - HTTP Status Code: `ResponseEntity` allows you to specify the HTTP status code to be returned in the response. (e.g., 200 for success, 404 for not found, 500 for internal server error, etc.).
    - HTTP Headers: You can add custom HTTP headers to the response using `ResponseEntity`. This is useful for setting headers like Content-Type, Cache-Control, Location, etc.
    - Response Body: `ResponseEntity` allows you to specify the body of the HTTP response. You can return different types of objects (e.g., POJOs, collections, strings) as the response body, and Spring will automatically serialize them to the appropriate format (e.g., JSON, XML) based on the content negotiation.
    - Flexibility: `ResponseEntity` provides flexibility in customizing the entire HTTP response.

9.  What is ResultSet in jdbc? And describe the flow how to get data using JDBC.

    `ResultSet` in JDBC is an interface that represents the result set of a database query. It provides methods to traverse and retrieve data from the result set, which is essentially the tabular data returned by an SQL query.

    Step to get data using JDBC:

    1. Load the JDBC driver:

    ```
        Class.forName("com.mysql.cj.jdbc.Driver");
    ```

    2. Establish a connection:

    ```
        String url = "jdbc:mysql://localhost:port/your_database";
        String username = "your_username";
        String password = "your_password";
        Connection connection = DriverManager.getConnection(url, username, password);
    ```

    3. Create a statement:

    ```
        Statement statement = connection.createStatement();
    ```

    4. Execute the query and return a ResultSet:

    ```
        String sql = "SELECT * FROM your_table";
        ResultSet resultSet = statement.executeQuery(sql);
    ```

    5. Process the ResultSet:

    ```
        while (resultSet.next()) {
        int id = resultSet.getInt("id");
        String name = resultSet.getString("name");
        // Process the data as needed
        }
    ```

    6. Close Resources:

    ```
        resultSet.close();
        statement.close();
        connection.close();
    ```

10. What is the ORM framework?

    ORM, Object-Relational Mapping. It is a programming technique used to convert data between incompatible systems in **object-oriented programming languages** and **relational databases**. It abstracted away the details of SQL queries and database operations, allowing developers to interact with the database using object-oriented principles rather than writing SQL queries directly.

    Key features of ORM frameworks:

    - Mapping: It bridges the gap between the object-oriented world of application development and the relational world of databases.
    - Persistence: ORM frameworks handle the persistence of objects, including operations such as inserting, updating, deleting, and querying objects in the database.
    - Transaction Management: RM frameworks provide transaction management capabilities to ensure that database operations are executed atomically and consistently.
    - Query Language (HQL in Hibernate)
    - The most popular ORM framework is **Hibernate**.

11. Learn how to use ObjectMapper by this example.

    https://github.com/TAIsRich/chuwa-eij-tutorial/blob/main/02-java-core/src/main/java/com/chuwa/exercise/oa/api/FoodOutletJackson.java

    The ObjectMapper allows you to convert Java objects to JSON and vice versa.

    - Serialization (Java Object to JSON): can use writeValueAsString() method of ObjectMapper
    - Deserialization (JSON to Java Object): can use the readValue() method of ObjectMapper

12. What is the serialization and desrialization?

    - Data serialization is the process of converting an object into a stream of bytes to more easily save or transmit it.
    - The deserialization is the process of constructing a data structure or object from a series of bytes.

13. Use stream api to get the average of the array [20, 3, 78, 9, 6, 53, 73, 99, 24, 32].

    ```
    int[] nums = new int[]{20, 3, 78, 9, 6, 53, 73, 99, 24};
    double avg = Arrays.stream(nums).average().orElse(0.0);
    ```

14. copied the code locally.
15. copied the code locally.
16. Practice Spring Data for Apache Cassandra already.
