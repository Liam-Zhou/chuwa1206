# Homework 12

- HW42-exception-validation

- HW42-Spring-Data: same as HW9

- HW43-Spring-Basic

## What is the @Configuration and @Bean?




- **@Configuration:**
  
  - The `@Configuration` annotation is used to indicate that a class contains bean definitions and configuration for the Spring IoC container.
  
  - Classes annotated with `@Configuration` are often referred to as configuration classes.
  
  - Configuration classes may contain methods annotated with `@Bean` to define Spring beans.
  
  - `@Configuration` is an alternative to XML-based configuration and is especially useful for Java-based applications.

- **@Bean:**
  
  - The `@Bean` annotation is used to declare a method as a producer of a bean managed by the Spring IoC container.
  - Methods annotated with `@Bean` are responsible for creating and configuring instances of beans to be managed by the container.
  - The return type of the method is the type of the bean, and the method name is the name of the bean.



## How do you handle the exception in Spring?



- Using `@ControllerAdvice` and a global exception handler class `GlobalExceptionHanlder` to handle all types of exceptions



## How do you do the validations in Spring? List some validation annotations you know



- We can use validation API, we need to add the dependency to `pom.xml` first

- add validation rules(annotations) to payload(Dto)
  
  - `@NotNull`: checks that the annotated element is not null
  
  - `@NotEmpty`: checks that the annotated string is not empty(not null and length > 0)
  
  - `@Size`: define the size constraints for string, collections or arrays
  
  - `@Email`: Checks the annotated string is a valid email address

- add `@Valid` to `controller` to apply the rule there





## What is the actuator? List some endpoints it provides



- Spring Boot Actuator is a set of production-ready features that help you monitor and manage your application. It provides several built-in endpoints that expose useful information about your application's health, metrics, environment, etc.

- Health: `/actuator/health`

- Info: `/actuator/info`

- Metrics: `/actuator/metrics`

- Env: `/actuator/env`

- Beans: `/actuator/beans`

- Configprops: `/actuator/configprops`

- Mapping: `/actuator/mappings`



## What is Spring and SpringBoot? What are the benefits of using SpringBoot?



- Spring: Spring is a comprehensive framework for Java development that provides infrastructure support, comprehensive programming and configuration models, and various libraries for building enterprise-level applications.

- SpringBoot: Spring Boot is an extension of the Spring framework that simplifies the process of building production-ready applications with Spring. It aims to make it easy to create stand-alone, production-grade Spring-based applications with minimal effort.

- SpringBoot core benefits:
  
  - Convention over Configuration: no need to write xml files configurations for frequently used features
  
  - Embedded Tomcat server and simplified packaging
  
  - Microservices support
  
  - SpringBoot starters and auto-configuration



## What is IoC and What is DI?



- IoC: Inversion of Control is a design principle where the control flow of a program is inverted, i.e., instead of the application controlling the flow of execution, the control is given to an external container or framework. The IoC principle is a way of achieving decoupling and making the code more modular and maintainable.

- DI: Dependency Injection is a specific implementation of the IoC principle. In DI, the dependencies of a class are injected from the outside rather than being created or managed within the class itself. This helps achieve loose coupling between components, making the code more modular, testable, and maintainable.



## What is @ComponentScan?



- `@ComponentScan` is a Spring Framework annotation used to enable component scanning in a Spring application. 

- Component scanning is the process by which Spring automatically discovers and registers Spring components (such as beans, services, and controllers) in the application context without the need for explicit XML or Java configuration.



## How to define which package Spring needs to scan in xml and annotation?



- xml: use `<context:component-scan base-package="packageName" />` to specify the base packages for component scanning

- annotations: `@ComponentScan(basePackages="packageName")` or `@SpringBootApplication` which includes `@Configuration`, `@EnableAutoConfiguration`, and `@CoponentScan`



## What is @SpringbootApplication?



- `@SpringBootApplication` = `@Configuration + @EnableAutoConfiguration + @ComponentScan`
  
  -  `@Configuration`: declares a class as the source for bean definitions
  
  - `@EnableAutoConfiguration`: allows the application to add beans using classpath definitions 
  
  - `@ComponentScan`: directs Spring to search for components in the path specified



## How many ways we can define a bean?



- Define beans in xml using the `<bean>` element

- In classes annotated with `@Configuration`, define beans using methods annotated with `@Bean`

- When enabling component scanning, annotate with `@Component`, `@Servcie`, `@Repository`, `@Controller`

- Use bean factory to create beans in xml or configuration class



## What is the default bean name for @Component and @Bean?



- `@Component` -> class name + converting the first letter to lowercase

- `@Bean` -> name of the `@Bean` method



## What is the difference between @Component and @Service, @Repository?



- `@Component`: indicating a Spring component, the primary purpose is to identify and register a class as a Spring  bean

- `@Service`: a specialization of `@Component` and is used to annotate classes that perform service-related tasks

- `@Repository`: a specialization of `@Component` and is used to annotate classes that work as Spring Data Repositories



## How many annotations we can use to inject the bean?



- `@Autowired`, `@Resource`, `@Inject`



## What are the 3 types of DI? Which is better and why?



- Constructor injection, setter injection, and field injection

- Constructor injection is better:
  
  - Immutability
  
  - Explicit Dependencies
  
  - Test-Friendliness
  
  - Avoid Circular Dependencies
  
  - Compatibility with Java Records



## If we have multiple beans for one type, how to set one as primary? and how to let the Spring pick one bean to inject if no primary?



- use `@Primary` to indicate that a particular bean should be considered as the primary bean for that type.

- If not primary bean is specified and there are multiple candidates you can use `@Qualifier` to specify the name of the bean to be injected.



```java
@Configuration
public class AppConfig {

    @Bean
    @Primary
    public MyInterface primaryBean() {
        return new PrimaryBean();
    }

    @Bean
    public MyInterface secondaryBean() {
        return new SecondaryBean();
    }
}
```



## What is the difference between BeanFactory and ApplicationContext in Spring?



- BeanFactory: Bean init/writing 
- ApplicationContext:
  - Bean init/writing 
  - Automatic BeanPostProcessor registration
  - Automatic BeanFactoryPostProcessor registration 
  - Convenient MessageSource access (for i18n)
  - ApplicationEvent Publication



## What is the Scope of a Bean? List the examples for each scope.



- General: Singleton, Prototype
  
  - Singleton: each container has only 1 that bean
  
  - Prototype: each time it is called it will create 1 bean

- Web specific: Request, Session, Application, Websocket

- specify with `@Scope("typeName")`



```java
@Component
@Scope("singleton")
public class MySingletonBean {
    // Bean definition...
}

@Component
@Scope("prototype")
public class MyPrototypeBean {
    // Bean definition...
}

```



## Configure a bean using xml. If beans has parameters/dependencies, how can we configure the bean?



- In XML-based configuration in Spring, you can define and configure a bean using the `<bean>` element. If the bean has parameters or dependencies, you can specify them within the `<constructor-arg>` or `<property>` elements.



```java
<!-- application-context.xml -->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- Bean configuration with constructor arguments -->
    <bean id="myBean" class="com.example.MyBean">
        <!-- Constructor arguments -->
        <constructor-arg name="name" value="ExampleName"/>
        <constructor-arg name="value" value="42"/>
    </bean>
</beans>


<!-- application-context.xml -->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Bean configuration with setter methods -->
    <bean id="myBean" class="com.example.MyBean">
        <!-- Setter methods -->
        <property name="name" value="ExampleName"/>
        <property name="value" value="42"/>
    </bean>

</beans>

```










