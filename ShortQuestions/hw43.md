# 2. Spring and Spring Boot
Spring Boot:

Spring Boot is a convention-over-configuration extension of the Spring framework, designed to simplify the bootstrapping and development of new Spring applications. It provides default configurations, which help to minimize boilerplate configuration code.
Benefits of Using Spring Boot:

+ Rapid Development: Offers "out-of-the-box" configurations to quickly start new projects.
+ Auto-configuration: Automatically configures your application based on the added dependencies.
+ Standalone: Creates standalone Spring applications that can be started using Java -jar.
+ Opinionated Defaults: Provides a set of default configurations to reduce development time.
+ Microservices Ready: Ideal for building microservices due to its embedded server and configuration options.
+ Wide Range of Features: Includes embedded servers, metrics, health checks, and externalized configuration.


# 3. IOC and DI
1. IOC (Inversion of Control):

Inversion of Control is a principle in software engineering where the control of objects or portions of a program is transferred to a container or framework. It's often used in the context of object creation, event handling, assembling objects, and more.
2. DI (Dependency Injection):

Dependency Injection is a design pattern used for achieving IOC. It allows the creation of dependent objects outside of a class and provides those objects to a class in different ways (e.g., through constructors, methods, or fields).

# 4. @ComponentScan
`@ComponentScan` is an annotation in Spring Framework that is used to **specify the packages to scan for annotated components**. It automatically detects and registers beans (e.g., @Component, @Service, @Repository, @Controller) to be used in the application context.

# 5. Defining Package Scan in XML and Annotation
```xml
<context:component-scan base-package="com.example.myapp" />
```
```java
@Configuration
@ComponentScan("com.example.myapp")
public class AppConfig {
    // Class definition
}
```
# 6. @SpringBootApplication
@SpringBootApplication is a convenience annotation in Spring Boot that encapsulates @Configuration, @EnableAutoConfiguration, and @ComponentScan with their default attributes. It's typically used on the main class of a Spring Boot application.

# 7. Ways to Define a Bean
1. Annotation-Based Configuration: Using annotations like @Component, @Service, @Repository, @Controller.
2. Java Configuration: Using @Bean annotation in a class annotated with @Configuration.
3. XML Configuration: Defining beans in an XML file using the <bean> tag.
4. Component Scanning: Automatically detecting components with @ComponentScan.
5. Factory Methods: Factory classes or factory methods that produce beans.
5. Spring Boot Auto-Configuration: Implicit bean definitions through Spring Boot's auto-configuration.

# 8. Default Bean Name for @Component and @Bean
1. For @Component: The default bean name is the uncapitalized class name. For instance, if your class is named MyService, the default bean name would be myService.
2. For @Bean: If a method is annotated with @Bean and it doesn't specify a name, the default bean name is the name of the method. For example, if you have a method myBean(), the default bean name would be myBean.
3. When you use @Autowired with an interface, Spring looks for a bean that matches the interface type in the application context and injects it

# 9. Difference Between @Component, @Service, and @Repository
1. @Component: This is a generic stereotype for any Spring-managed component. It indicates that the class is a Spring component.
2. @Service: This is a specialization of @Component and is used to indicate that the class provides business functionalities. It's more about service-layer logic.
3. @Repository: Another specialization of @Component, this is used for classes that interact with the database. It encapsulates database access and operations.

# 10. Annotations for Bean Injection
There are several annotations that can be used for injecting beans in Spring, like @Autowired, @Inject, @Resource, etc.

# 11. Three Types of Dependency Injection
1. Constructor Injection: Dependencies are provided through a class constructor.
2. Setter Injection: The Spring container calls setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.
3. Field Injection: Dependencies are injected directly into the fields of your class.
The best method often depends on the specific use case, but **constructor injection is generally recommended** for mandatory dependencies and immutable objects because it allows for the instantiation of an object in a fully initialized state.

# 12. Handling Multiple Beans of One Type
1. Set Primary Bean: Use the @Primary annotation on one of the beans to designate it as the primary bean.
2. specify Bean to Inject: If no primary bean is set, you can use the @Qualifier annotation to specify which bean to inject.
```java
public interface VehicleService {
    String getServiceType();
}

@Component
public class CarService implements VehicleService {
    @Override
    public String getServiceType() {
        return "Car Service";
    }
}

@Component
@Primary  // This annotation makes BikeService the primary bean
public class BikeService implements VehicleService {
    @Override
    public String getServiceType() {
        return "Bike Service";
    }
}
```
```java
@Component
public class VehicleClient {

    private final VehicleService vehicleService;

    @Autowired
    public VehicleClient(@Qualifier("carService") VehicleService vehicleService) {
        this.vehicleService = vehicleService;
    }

    public void performService() {
        System.out.println(vehicleService.getServiceType());
    }
}
```

# 13. Difference Between BeanFactory and ApplicationContext
1. BeanFactory: It's a basic container that manages beans. It lazily initializes beans, i.e., beans are created when requested.
2. ApplicationContext: Extends BeanFactory with additional features. It's more advanced and provides functionalities like event publication, AOP, internationalization, etc. Beans in ApplicationContext are eagerly loaded by default unless lazy-loading is explicitly configured.

# 14. Scope of a Bean
1. Singleton: (Default) Only one instance of the bean is created for the entire application.
2. Prototype: A new instance is created each time the bean is requested.
3. Request: A new instance is created for each HTTP request.
4. Session: A new instance is created for each HTTP session.
5. Global Session: A new instance is created for global HTTP sessions (typically in a Portlet context).
6. Application: Bean is scoped to the lifecycle of a ServletContext.
6. WebSocket: Bean is scoped to the lifecycle of a WebSocket.

# 15. Configure a bean using xml.
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Definition for engineService bean -->
    <bean id="engineService" class="com.example.EngineService" />

    <!-- Definition for carService bean with dependency injection -->
    <bean id="carService" class="com.example.CarService">
        <property name="engineService" ref="engineService"/>
    </bean>

</beans>
```