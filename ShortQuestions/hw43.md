
2. What is Spring and Springboot? What is the benfits of using Srpingboot?

    - Spring is a popular open-source framework for building Java-based enterprise applications. It provides comprehensive infrastructure support, making it easier to develop robust and scalable applications. The core features of the Spring framework include dependency injection, aspect-oriented programming, transaction management, and more.
    - Spring Boot, on the other hand, is a project within the Spring ecosystem that simplifies the process of building production-ready applications with the Spring framework. It aims to minimize the amount of configuration needed for setting up Spring applications by providing defaults for many configuration parameters. Spring Boot also includes a set of conventions for application structure, making it easier for developers to get started with building applications quickly.
    - Benefits: Simplified Configuration, Rapid Development, Microservices Support, Built-in Features, Testing Support

3. What is IOC and What is DI?

    - IoC: In traditional programming, the application code is responsible for creating and managing the objects it depends on. With IoC, the responsibility is inverted, and the framework or container takes charge of creating and managing objects.
      The Spring IoC container is responsible for managing the lifecycle of objects, resolving dependencies, and invoking methods. This allows for more flexible and modular code.
    - DI: DI is a specific implementation of IoC. It is a technique where the dependencies of a class are injected (provided) from the outside rather than being created within the class.

4. What is @ComponentScan?

    - @ComponentScan is an annotation in the Spring framework that is used to enable component scanning in a Spring application. Component scanning is a feature that allows Spring to automatically discover and register Spring components (such as beans, controllers, services, and repositories) in your application without explicitly declaring them in configuration files.

5. How to define which package spring need to scan in xml and annotation?

   1. Annotation-Based Configuration: Using @ComponentScan Annotation
   2. XML-Based Configuration: Using <context:component-scan> Element

6. What is @SpringbootApplication?

    - @SpringBootApplication is a meta-annotation in the Spring framework that combines three commonly used annotations in Spring Boot applications. Includes: @Configuration, @EnableAutoConfiguration, @ComponentScan

7. How many ways wo can define a bean?

    - XML Configuration
    - Annotation-Based Configuration: Use annotations like @Component, @Service, @Repository, or @Controller on classes to automatically register them as beans.
    - Java Configuration: Use Java configuration classes annotated with @Configuration to define beans using @Bean methods.
    - Factory Method: Define beans using factory methods within a configuration class or an existing bean.
    - Import Configuration: Use @Import annotation to import bean configurations from other configuration classes.
    - Component Scanning: Enable component scanning using @ComponentScan to automatically detect and register beans in specified packages.
    - Initializing Beans with Lifecycle Methods: Implement the InitializingBean interface or use @PostConstruct annotated methods to perform initialization logic after bean creation.


8. What is default bean name for @Component and @Bean?

    - The default bean name is derived from the name of the annotated class or the method.

9. What is the difference between @component and @service,@repository?

    - @Component: The most generic stereotype annotation.
      Used to indicate that a class is a Spring component, which can be automatically discovered and registered by the Spring container.
      Suitable for any general-purpose component.
    - @Service: A specialization of @Component used to indicate that a class represents a service or business logic component in the application.
    - @Repository: A specialization of @Component used to indicate that a class represents a repository or data access component in the application.



10. How many annotaitons we can use to inject the bean?

    1. @Autowired: Used to automatically inject a bean by type.
    2. @Qualifier: Used in conjunction with @Autowired to specify which bean to inject when multiple beans of the same type are available.
    3. @Resource: Can be used for injecting a bean by name, type, or a combination of both.
       Works with both field and method injection.
    4. @Inject: Similar to @Autowired and is part of the Java Dependency Injection (JSR-330) standard.
       Supports field, method, and constructor injection.
    5. @Value: Used to inject values from property files or configuration into beans.
    6. @Lazy: Used to specify lazy initialization of a bean. The bean is created only when it is first requested.

11. Tell me the three types to do dependency injection(How can we inject the beans
    in Spring)? Which way is better and why?

    - Constructor Injection, Setter Injection and Field Injection.
    - Constructor Injection (Preferred): 
        1. It ensures that the dependent object is in a valid state from the moment it is created, promoting immutability and thread safety.
      2. It makes dependencies explicit and clear, improving code readability.
      3. Constructor injection is easier to test since dependencies are set during object creation, and there is no risk of the object being in an incomplete state.
      4. Avoid Circular Dependencies: With constructor injection, dependencies are explicitly declared in the constructor parameters. The order of constructor parameters represents the order in which dependencies are resolved during object creation.
         If there is a circular dependency, Spring will detect it at the time of bean initialization and throw an exception.
      5. Compatibility with Java Records: Record types, introduced in Java 14 and
         officially available since Java 16, are immutable and require constructors to set
         fields. Constructor injection is naturally compatible with record types, while
         field injection is not.

12. If we have multiple beans for one type, how to set one is primary? and how to let
    the spring to pick one bean to inject if no primary.

    - Setting a Primary Bean:
      1. Using @Primary Annotation: You can annotate one of the beans with @Primary to indicate that it is the primary bean for its type.
    - Selecting a Bean when No Primary is Specified:
      1. Using @Autowired with @Qualifier: When injecting a bean, you can use the @Qualifier annotation along with @Autowired to specify the name of the bean to inject. If no primary bean is specified, Spring will fall back to the bean with the matching qualifier.
      2. Programmatic Lookup: You can use programmatic lookup using ApplicationContext to manually retrieve the desired bean based on its name or type.
      ```
      @Component
      public class MyComponent {
      @Autowired
      private ApplicationContext context;

      public void someMethod() {
        MyInterface myBean = context.getBean(MyInterface.class);
        // Use myBean
      }
      }
      ```
        

13. What is the difference between BeanFactory and ApplicationContext in Spring?

    1. Initialization Time: BeanFactory: Lazy initialization: Beans are initialized when first requested. ApplicationContext: Eager initialization: Beans are initialized at the time of application startup.
    2. Bean Lifecycle and Post-Processing: BeanFactory: Supports basic bean lifecycle management.
       Limited support for advanced features like bean post-processing. ApplicationContext: Extends BeanFactory and adds additional features.
       Supports full bean lifecycle management, including advanced features like event propagation and application context events.
       Provides more extensive support for bean post-processing.
    3. Event Propagation: BeanFactory: Limited support for event propagation. ApplicationContext: Extensive support for event propagation.
    4. AOP Features: BeanFactory: Basic support for AOP. ApplicationContext: Extends BeanFactory and provides advanced AOP features.

14. What is the Scope of a Bean? and list the examples for each scope.

    - Singleton Scope: In singleton scope, a single bean instance is created and shared across the entire application context.
    ```In singleton scope, a single bean instance is created and shared across the entire application context.```
    - Prototype Scope: In prototype scope, a new bean instance is created every time it is requested from the container.
      Each request for the bean results in a new instance.
    - Request Scope: In request scope, a new bean instance is created for each HTTP request in a web-based application.
      The bean is available as long as the HTTP request is active.
    - Session Scope: In session scope, a new bean instance is created for each user session in a web-based application.
      The bean is available throughout the entire user session.

15. Configure a bean using xml. If bean has parameters/dependencies, how can we
    configure the bean? (you can google the tutorial how to configure beans in xml,
    and feel free to ask me any quesitons if you don't understand. it is a little bit old,
    I am not sure if I need to exaplain it in class)

    - Constructor Injection Example: For a Person class 
    ```
    public class Person {
      private String name;
      private int age;

    // Constructor
    public Person(String name, int age) {
    this.name = name;
    this.age = age;
    }

    }
    ```

    ```
    <bean id="personBean" class="com.example.Person">
            <constructor-arg value="John Doe" />
            <constructor-arg value="25" />
        </bean>
    ```

    - The bean element defines a bean with the ID personBean of type com.example.Person.
The constructor-arg elements inside the bean element provide values for the constructor parameters.

    - For a setter injection: 
    ```
    <bean id="personBean" class="com.example.Person">
        <property name="name" value="John Doe" />
        <property name="age" value="25" />
    </bean>
    ```

    - The property elements inside the bean element provide values for the setter methods.