3. Aspect-oriented programming (AOP) is a programming technique that supports the separation of **cross-cutting concerns** in order to increase modularity.

   cross-cutting concerns are tasks that need to be executed in multiple places across the application like logging and security. They need to be centralized as much as possible to increase modularity.

4. ##### Advantages of Spring AOP

   1. It is easy to configure.
   2. Spring AOP is implemented in pure Java, so separate compilation unit or separate class loader are not required.
   3. It utilizes Spring's IOC container for dependency injection.
   4. Can create aspects using `@AspectJ` annotation based or using XML based.
   5. It integrates cross-cutting concerns into the classes,.

   ##### Disadvantages of Spring AOP

   1. Debugging the AOP framework-based application code is a little challenge.
   2. Only methods with a public visibility will be recommended, not those with a private, protected, or default visibility.
   3. Aspects cannot be advised by other aspects. This is because once a class is marked as an aspect (using XML or annotation), Spring prevents it from being auto-proxied.

5. An aspect is a cross-cutting module that combines advice and pointcuts. A standard class tagged with the `@Aspect` annotation can be used to implement an aspect.

6. Pointcut is expressions that are matched with join points to determine whether advice needs to be executed or not. Pointcut uses different kinds of expressions that are matched with the join points and Spring framework uses the AspectJ pointcut expression language.

7. A join point is a specific point in the application such as method execution, exception handling, changing object variable values, etc. In Spring AOP a join point is always the execution of a method.

8. Advices are actions taken for a particular join point. In terms of programming, they are methods that get executed when a certain join point with matching pointcut is reached in the application.

   ###### AOP Advice Types

   Based on the execution strategy of advice, they are of the following types.

   1. **Before Advice**: These advices runs before the execution of join point methods. We can use `@Before` annotation to mark an advice type as Before advice.
   2. **After (finally) Advice**: An advice that gets executed after the join point method finishes executing, whether normally or by throwing an exception. We can create after advice using `@After` annotation.
   3. **After Returning Advice**: Sometimes we want advice methods to execute only if the join point method executes normally. We can use `@AfterReturning` annotation to mark a method as after returning advice.
   4. **After Throwing Advice**: This advice gets executed only when join point method throws exception, we can use it to rollback the transaction declaratively. We use `@AfterThrowing` annotation for this type of advice.
   5. **Around Advice**: This is the most important and powerful advice. This advice surrounds the join point method and we can also choose whether to execute the join point method or not. We can write advice code that gets executed before and after the execution of the join point method. It is the responsibility of around advice to invoke the join point method and return values if the method is returning something. We use `@Around` annotation to create around advice methods.

9. .

10. Spring batch framework can be used when a task requires batch processing, for example, generating financial reports at end of day or month. 

11. Batch processing includes tasks like reading and writing to files, transforming data, reading and writing to databases etc. These steps are often chained together and can also be executed sequentially or in parallel. If an error occurs in a batch job step, then it can be found out that in which step, the error has occurred and it is also possible to resume that job execution from that failed step.

12. using Spring Task

13. A *cron expression* is a string consisting of six or seven subexpressions (fields) that describe individual details of the schedule. These fields, separated by white space, can contain any of the allowed values with various combinations of the allowed characters for that field.

14. Spring is a mechanism that allows you to scheduling tasks to be executed at specified time.

15. Scheduling tasks in Spring applications can be an effective way to automate processes, perform maintenance, and enhance your application’s functionality. 

16. A filter as the name suggests is a Java class executed by the servlet container for each incoming HTTP request and for each HTTP response. This way is possible to manage HTTP incoming requests before they reach the resource, such as a JSP page, a servlet or a simple static page; in the same way, is possible to manage HTTP outbound response after resource execution.

    - Authentication Filters
    - Data compression Filters

17. Spring Interceptors are used to intercept requests and responses at the controller level. They are executed before the controller method is invoked and after the controller method has returned. This means that you can modify the request or response before it reaches the controller or after it has been processed by the controller.

    Interceptors are typically used for:

    - Authentication and authorization
    - Logging
    - Performance monitoring
    - Customizing the request or response

18. - preHandle() – Executed before the controller method is invoked. This method returns a boolean value indicating whether to continue processing the request or abort the request.
    - postHandle() – Executed after the controller method has returned, but before the view is rendered. This method allows you to modify the model or view before rendering.
    - afterCompletion() – Executed after the view has been rendered. This method allows you to perform any cleanup tasks.

19. Swagger is a documentation framework that  allows you to describe the structure of your APIs so that machines can read them.