### HW46 

## Q2. Reading: https://www.techgeeknext.com/spring-boot/spring-aop-interview-questions
## Q3. What is the Aspect Oriented Programming?
Aspect-oriented programming (AOP) is a programming technique that supports the separation of cross-cutting concerns in order to increase modularity.

## Q4.  What are the advantages and disadvantages of Spring AOP?
- Advantages
	- It is easy to configure.
	- Spring AOP is implemented in pure Java, so separate compilation unit or separate class loader are not required.
	- It utilizes Spring's IOC container for dependency injection.
	- Can create aspects using @AspectJ annotation based or using XML based.
	- It integrates cross-cutting concerns into the classes.

- Disadvantages of Spring AOP
	- Debugging the AOP framework-based application code is a little challenge.
	- Only methods with a public visibility will be recommended, not those with a private, protected, or default visibility.
	- Aspects cannot be advised by other aspects. This is because once a class is marked as an aspect (using XML or annotation), Spring prevents it from being auto-proxied.

## Q5.  What is Aspect in Spring AOP?
An aspect is a cross-cutting module that combines advice and pointcuts. A standard class tagged with the @Aspect annotation can be used to implement an aspect.

## Q6.  What is Pointcut in Spring AOP?
In Spring AOP, a pointcut is an expression that selects one or more join points (specific points in the execution of the application, such as method executions or object initializations) where advice (code meant to add additional behavior) should be applied. Pointcuts help in specifying where the aspects (modularizations of concerns, such as logging or transaction management) should be applied, making them a crucial concept in AOP.
```java
@Aspect
@Component
public class MyAspect {

    // Pointcut that matches all methods in the service package
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceLayerExecution() {}

    // Advice that runs before the matched method execution
    @Before("serviceLayerExecution()")
    public void beforeServiceLayerExecution(JoinPoint joinPoint) {
        // Advice implementation, e.g., logging the method call
        System.out.println("Before executing: " + joinPoint.getSignature());
    }
}

```

## Q7. What is the Join point in Spring AOP?
In Spring AOP, a join point represents a point in the execution of a program where an aspect can be applied. It defines specific points in the application where additional behavior can be inserted before, after, or around the main logic. Example:
```java
public class MyService {
    public void performAction() {
        // Method logic
    }
}
```
```java
@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.MyService.performAction(..))")
    public void logBeforeAction(JoinPoint joinPoint) {
        System.out.println("Before executing: " + joinPoint.getSignature().getName());
    }
}
```
In this example, the `logBeforeAction` method is an advice that is executed before the `performAction` method of `MyService`. The execution pointcut expression specifies the join point, which is the execution of `performAction`.

## Q8.  What does it mean by Advice and its types in Spring AOP?
The advice is an action which we take before or after the method execution. In the Spring AOP framework, there are five types of advice: before, after, after-returning, after-throwing, and around advice. Advice is taken at a specific join point.

## Q9.  Reading: https://www.javainuse.com/spring/sprbatch_interview
## Q10. When to use Spring Batch?
Use Spring Batch when users have to do a lot of batch processing. Batch processing includes typical tasks like reading and writing to files, transforming data, reading from or writing to databases, create reports, import and export data and things like that. Spring Boot Batch provides reusable functions that are essential in processing large volumes of records, including logging/tracing, transaction management, job processing statistics, job restart, skip, and resource management.

## Q11. How Spring Batch works?

- Core Concepts:
	- Job: In Spring Batch, a job is the entire batch process that needs to be executed. It's composed of one or more steps, which are executed in sequence or conditionally based on the job's configuration.
	- Step: A step is an independent, sequential phase of a job, representing a single task that forms part of the larger batch process. Each step typically involves reading data, processing it, and writing the processed data.
	- ItemReader: The component responsible for reading input data from a resource (such as a file, database, or message queue). It reads the data item by item, which are then passed on for processing.
	- ItemProcessor: An optional component that transforms or processes each item. The processor takes one item as input, applies business logic or transformations, and outputs the processed item.
	- ItemWriter: Responsible for writing processed items to a specified destination, such as a database, file, or message queue. It typically writes items in batches for efficiency.

- Execution Flow:
	- Job Launch: A job is initiated, usually triggered by a scheduler (like cron jobs or Spring's TaskScheduler), a web service call, or an application event.
	- Step Execution: The job proceeds to execute its defined steps. Each step involves:
		- Reading: The ItemReader reads a chunk of items from the input source.
		- Processing: Each item read is passed to the ItemProcessor (if defined), where it can be transformed or processed.
		- Writing: Processed items are collected and handed over to the ItemWriter to be written out in a batch.
	- Commit: Spring Batch follows a chunk-oriented processing model, where each chunk of items is processed in a transaction. Once a chunk is successfully read, processed, and written, the transaction is committed.

	- Repeat or End: If there are more items to be processed, the next chunk is read, and the process repeats. If all items have been processed, or if an end condition is met, the step completes.

	- Job Completion: Once all steps are executed (either successfully or with failure), the job ends. Jobs can have various outcomes like COMPLETED, FAILED, STOPPED, etc.

## Q12. How can we schedule a Spring Batch Job?
1. Using `@Scheduled` Annotation: `@Scheduled` annotation allows you to define fixed-rate, fixed-delay, or cron-based tasks directly on methods.
```java
@Configuration
@EnableBatchProcessing
@EnableScheduling
public class BatchConfig {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job myBatchJob;

    @Scheduled(cron = "0 0 12 * * ?") // Run daily at noon
    public void runJob() {
        Map<String, JobParameter> jobParametersMap = new HashMap<>();
        jobParametersMap.put("time", new JobParameter(System.currentTimeMillis()));
        JobParameters parameters = new JobParameters(jobParametersMap);

        try {
            jobLauncher.run(myBatchJob, parameters);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
2. Using `TaskScheduler`
```java
@Configuration
@EnableBatchProcessing
public class BatchSchedulerConfig {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job myBatchJob;

    @Autowired
    private TaskScheduler taskScheduler;

    @PostConstruct
    public void scheduleJob() {
        taskScheduler.schedule(this::runBatchJob, new CronTrigger("0 0 12 * * ?")); // Run daily at noon
    }

    public void runBatchJob() {
        Map<String, JobParameter> jobParametersMap = new HashMap<>();
        jobParametersMap.put("time", new JobParameter(System.currentTimeMillis()));
        JobParameters parameters = new JobParameters(jobParametersMap);

        try {
            jobLauncher.run(myBatchJob, parameters);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## Q13. What is the cron expression?
Cron expressions are commonly used in schedulers like Spring's @Scheduled annotation to define when a particular task should be executed. The fields in a cron expression represent the following: Second, Minute, Hour, Day of Month, Month, Day of Week, Year.

Special characters can be used to represent multiple values or intervals:
- * (Asterisk): Represents all possible values for a field. For example, * in the hour field means "every hour".
- - (Hyphen): Specifies ranges. For example, 1-3 in the day of week field means "Monday through Wednesday".
- , (Comma): Specifies additional values. For example, MON,WED,FRI in the day of week field means "Mondays, Wednesdays, and Fridays".
- / (Slash): Specifies increments. For example, 0/15 in the minutes field means "every 15 minutes starting from minute 0".
- ? (Question Mark): Used in the day of month and day of week fields to signify "no specific value" and is often used when specifying a value for one and not the other.
- L (Last): Has different meanings when used in the day of month or day of week fields. For example, L in the day of month field means "the last day of the month".
- W (Weekday): Used in the day of month field to specify the nearest weekday to a given day. For example, 15W means "the nearest weekday to the 15th of the month".
- # (nth): Used in the day of week field to specify the nth occurrence of a particular day within a month. For example, 2#1 means "the second Monday of the month".


## Q14. What is the spring task?
In the context of the Spring Framework, a "Spring Task" refers to the execution of an asynchronous or scheduled piece of work, managed by Spring. Spring provides extensive support for task execution and scheduling, allowing developers to run asynchronous methods or schedule tasks to be executed periodically. This functionality is particularly useful for applications that require background processing, scheduled jobs, or any task that should not block the main execution flow.

## Q15. When to use Spring task? 
Here are some common use cases and scenarios where you might use Spring Task:
1. Asynchronous Processing: When you need to execute long-running tasks without blocking the main execution thread or the web request, Spring Task's asynchronous capabilities are ideal. Examples:
	- Performing complex calculations or processing in the background.
	- Handling file uploads and processing the files asynchronously.

2. Scheduled Tasks: Spring Task is excellent for tasks that need to run on a schedule, such as daily reports, periodic data synchronization, or maintenance tasks. Examples:
	- Generating nightly or weekly reports.
	- Performing database cleanup operations at regular intervals.

3. Background Jobs: For applications that require background jobs to process data, perform calculations, or interact with other systems without user intervention, Spring Task provides a straightforward approach. Examples:
	- Processing queued items at fixed intervals.
	- Running data aggregation or analytics operations in the background.
	- Monitoring system health or performance metrics periodically.

## Q16. What is Filter and any filter example?
In web applications, a filter is a component that allows you to perform filtering tasks on requests to and responses from a web application. Filters are used for a variety of purposes, such as logging request information, authentication and authorization, modifying request headers or bodies, modifying response headers or bodies, and more. Example:
```java
@Component
public class CustomFilter implements Filter {

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) 
            throws IOException, ServletException {
        
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        // Log the HTTP method and request URI
        System.out.println("Incoming request " + request.getMethod() + " " + request.getRequestURI());

        // Check for a specific custom header in the request
        String customHeader = request.getHeader("X-Custom-Header");
        if (customHeader == null) {
            // If the header is missing, block the request and return a 400 Bad Request
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "X-Custom-Header is missing");
            return; // Important to stop the filter chain here
        }

        // Proceed with the filter chain
        filterChain.doFilter(request, response);

        // Add a custom header to the response
        response.addHeader("X-Custom-Response-Header", "CustomValue");
    }
}

```
In this example, requests with X-Custom-Header: Should pass through the filter, log the request details, and include the X-Custom-Response-Header in the response. Requests without X-Custom-Header: Should be blocked by the filter, and you should receive a 400 Bad Request response indicating that the X-Custom-Header is missing.

## Q17. What is the Interceptor? What we can do with interceptor?
In the context of web development and frameworks like Spring, an interceptor is a component that allows you to intercept and process requests and responses before and after they are handled by a controller. Interceptors provide a mechanism to implement cross-cutting concerns in a web application, such as logging, authentication, authorization, and performance monitoring, in a centralized and reusable way.

## Q18. In Interceptor, What is preHandle? What is postHandle?
- The `preHandle` method is called before the target handler (controller method) is executed. It allows for pre-processing of the HTTP request.
```java
boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
```
- The postHandle method is called after the handler method has been executed but before the view is rendered. It allows for post-processing of the HTTP request and modifying the ModelAndView object that will be used to render the view.
```java
void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)
```

## Q19. What is Swagger?
Swagger is an open-source software framework backed by a large ecosystem of tools that helps developers design, build, document, and consume RESTful web services. It offers a set of tools for generating interactive API documentation, client SDK generation, and API testing.


