# HW10

## 1. What is Spring and Springboot? What are the benefits of using Springboot?

Spring is a powerful, lightweight framework used for building Java applications. It provides extensive infrastructure support for developing Java applications and services.

Spring Boot, a module of Spring, simplifies the bootstrapping and development of new Spring applications. It uses an opinionated approach to configuration, making it easy to create stand-alone, production-grade applications.

**Benefits of using Spring Boot:**

- **Easy to Start**: Simplifies Spring application setup and configuration.
- **Stand-alone**: Creates stand-alone Spring applications with minimal configurations.
- **Opinionated Defaults**: Offers 'out-of-the-box' configurations for quick setup and reduced development time.
- **Embedded Server**: Embeds Tomcat, Jetty, or Undertow directly, eliminating the need for WAR files.
- **Microservices Ready**: Ideal for building microservices, thanks to its quick setup and cloud-ready nature.
- **Spring Ecosystem**: Seamless integration with other parts of the Spring ecosystem like Spring Data, Spring Security, etc.

## 2. What is IOC and what is DI?

**IOC (Inversion of Control):** Inversion of Control is a principle in software engineering where the control of objects or portions of a program is transferred to a container or framework. Instead of the application calling the framework, the framework calls the application. This helps in decoupling the execution of a task from its implementation.

**DI (Dependency Injection):** Dependency Injection is a design pattern used in IOC, where an object receives its dependencies from external sources rather than creating them itself. DI facilitates loose coupling and easier testing by allowing dependencies to be replaced or mocked.

## 3. What is @CompnonentScan?

**`@ComponentScan`** is an annotation in the Spring framework. It's used to specify the packages that the Spring framework should scan for components, configurations, and services. This enables automatic detection and registration of components (like **`@Component`**, **`@Service`**, **`@Repository`**, **`@Controller`** annotations) within the specified package paths.

By default, if no specific package is defined, **`@ComponentScan`** scans the package where the application class with the **`@SpringBootApplication`** annotation is located and all its sub-packages.

## 4. How to define which package Spring needs to scan in XML and annotation?

1. Using Annotations:
   - **`@ComponentScan`** annotation is used in a configuration class (typically marked with **`@Configuration`**). You specify the base packages to scan as attributes of this annotation.
   - Example: **`@ComponentScan(basePackages = "com.example.project")`** tells Spring to scan the **`com.example.project`** package and its sub-packages for components.
2. Using XML Configuration:
   - In XML configuration, you use the **`<context:component-scan>`** tag to specify the base package.
   - Example: **`<context:component-scan base-package="com.example.project"/>`** in your XML file achieves the same effect as the annotation-based configuration.

## 5. What is @SpringBootApplication?

**`@SpringBootApplication`** is a key annotation in Spring Boot, a module of the Spring framework. It combines three important annotations, simplifying the Spring application setup:

1. **@Configuration:** Designates the class as a source of bean definitions for the application context.
2. **@EnableAutoConfiguration:** Enables Spring Boot's auto-configuration mechanism, which automatically configures your Spring application based on the dependencies that are present on the classpath.
3. **@ComponentScan:** Instructs Spring to scan for components, configurations, and services in the package where the class is located, allowing it to detect and register your Spring Beans automatically.

## 6. How many ways can we define a bean?

1. Annotation-based Configuration:
   - Using **`@Bean`** annotation in a **`@Configuration`** class. Each method annotated with **`@Bean`** produces a bean to be managed by the Spring container.
   - Component Scanning: Classes annotated with **`@Component`**, **`@Service`**, **`@Repository`**, or **`@Controller`** are automatically detected and registered as beans.
2. XML Configuration:
   - Defining beans in an XML file using the **`<bean>`** tag. This is the traditional way of defining beans, especially in older Spring applications.
3. Java-based Configuration:
   - Using Java classes for configuration. This approach combines **`@Configuration`** annotated classes with **`@Bean`** annotated methods.
4. Groovy Bean Definition DSL:
   - For applications that use Spring's Groovy configuration, beans can be defined using Spring's Groovy-based DSL (Domain Specific Language).

## 7. What is the default bean name for @Component and @Bean?

1. **@Component**: The default bean name for a class annotated with **`@Component`** (and its specializations like **`@Service`**, **`@Repository`**, **`@Controller`**) is the uncapitalized version of the class name. This is derived by decapitalizing the simple name of the class. For example, if your class is named **`MyService`**, the default bean name will be **`myService`**.
2. **@Bean**: For methods annotated with **`@Bean`**, the default bean name is the name of the method. For instance, if you have a method **`myBean()`** annotated with **`@Bean`**, the default name of the bean will be **`myBean`**.

These default names can be overridden by explicitly specifying a name. For **`@Component`**, you can do this using **`@Component("customName")`**, and for **`@Bean`**, you can do it by declaring **`@Bean(name = "customName")`**.

## 8. What is the difference between @Component and @Service, @Repository?

1. @Component:
   - **General Purpose:** It's a generic stereotype for any Spring-managed component. Use **`@Component`** when a class doesn’t fit any other stereotype.
   - **Layer Agnostic:** It doesn’t imply any specific role or layer in the application.
2. @Service:
   - **Service Layer:** Specifically intended for use in the service layer.
   - **Business Logic:** It indicates that the class holds business logic and calls methods in the repository layer.
   - **Semantics:** While functionally similar to **`@Component`**, using **`@Service`** adds additional semantic meaning, making the application more readable.
3. @Repository:
   - **Data Access Layer:** Intended for use in the data access layer, typically with database interactions.
   - **Exception Translation:** It can translate specific database-related exceptions to Spring’s DataAccessException.
   - **Persistence Layer:** Signifies that the class deals with data access mechanisms like a DAO (Data Access Object).

## 9. How many annotations can we use to inject the bean?

1. **@Autowired**: This is the most commonly used annotation for automatic dependency injection. It can be used on constructors, setters, and fields to inject beans by type.
2. **@Inject**: Similar to **`@Autowired`**, but it's a part of the Java CDI (Contexts and Dependency Injection) standard (JSR-330). **`@Inject`** can be used interchangeably with **`@Autowired`** but requires an additional dependency in your classpath.
3. **@Resource**: This annotation, part of the Java standard (JSR-250), injects beans by name. It can be used on fields and setter methods.
4. **@Qualifier**: Often used in conjunction with **`@Autowired`** to further specify the bean to be injected when multiple beans of the same type are present.
5. **@Value**: Used for injecting values into fields, such as primitives or String literals, often from external configuration or property files.

## 10. Tell me the three types to do dependency injection (How can we inject the beans in Spring)? Which way is better and why?

1. **Constructor Injection:**

   ```java
   @Component
   public class MyService {
       private final MyRepository myRepository;
   
       @Autowired
       public MyService(MyRepository myRepository) {
           this.myRepository = myRepository;
       }
   }
   ```

2. **Setter Injection:**

   ```java
   @Component
   public class MyService {
       private MyRepository myRepository;
   
       @Autowired
       public void setMyRepository(MyRepository myRepository) {
           this.myRepository = myRepository;
       }
   }
   ```

3. **Field Injection:**

   ```java
   @Component
   public class MyService {
       @Autowired
       private MyRepository myRepository;
   }
   ```

**Best Practices Favor Constructor Injection**: It's generally recommended to prefer constructor injection as it promotes immutability, ensures that required dependencies are not null, and enhances testability. It makes the dependencies of a class clear and explicit, leading to more maintainable code.

## 11. If we have multiple beans for one type, how to set one as primary, and how to let Spring pick one bean to inject if no primary is set.

1. **Using @Primary:**

   - Mark the bean you want to give preference to with **`@Primary`**.

   - Example:

     ```java
     @Component
     @Primary
     public class PrimaryBean implements MyInterface {
         // implementation
     }
     
     @Component
     public class SecondaryBean implements MyInterface {
         // implementation
     }
     ```

2. **Using @Qualifier:**

   - When injecting the bean, use **`@Qualifier`** to specify which bean to use.

   - Example:

     ```java
     @Component
     public class MyService {
         private final MyInterface myBean;
     
         @Autowired
         public MyService(@Qualifier("secondaryBean") MyInterface myBean) {
             this.myBean = myBean;
         }
     }
     ```

## 12. What is the difference between BeanFactory and ApplicationContext in Spring?

1. BeanFactory:
   - It's a basic version for creating and managing beans in Spring.
   - Beans are created when you ask for them (lazy initialization).
   - It's good for lightweight applications.
2. ApplicationContext:
   - It's an advanced version of **`BeanFactory`** with more features.
   - Beans are usually created at the start (eager initialization).
   - It supports things like web applications, internationalization, and events.
   - Preferred for more complex or enterprise-level applications.

**Relationship:**

- **`ApplicationContext`** includes all functionality of **`BeanFactory`** and introduces more enterprise-specific capabilities.
- It's a sub-interface of **`BeanFactory`**, so it offers everything **`BeanFactory`** does and more.

**Usage by Developers:**

- **Most Commonly Used:** Developers typically use **`ApplicationContext`**. It's the more advanced option and is generally recommended for most use cases, especially in modern Spring applications.
- **Features:** **`ApplicationContext`** provides more features, such as easier integration with Spring's AOP features, support for internationalization, web application contexts, event propagation, and more.
- **BeanFactory Use:** **`BeanFactory`** might still be used in very specific scenarios where minimal resources are required, and the application needs only basic Spring functionalities. However, these cases are rare in modern Spring development.

## 13. What is the Scope of a Bean? List examples for each scope.

1. **Singleton (default):**

   - **Lifecycle:** Only one instance of the bean is created per Spring IoC container.
   - **Example:** A configuration service or a DAO (Data Access Object) that is shared across the application.

   ```java
   @Service
   public class ConfigurationService {
       // Service methods
   }
   // Used across the application, same instance every time.
   ```

2. **Prototype:**

   - **Lifecycle:** A new instance is created each time the bean is requested.
   - **Example:** Objects where each request needs a separate instance, like processing user requests with distinct state.

   ```java
   @Scope("prototype")
   @Component
   public class RequestProcessor {
       // Processing logic
   }
   // A new instance is created every time it's injected.
   ```

3. **Request:**

   - **Lifecycle:** A single instance per HTTP request; created and valid during an individual request.
   - **Example:** A bean that stores data pertinent to a specific web request in a web application.

   ```java
   @Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
   @Component
   public class RequestDataHolder {
       // Data fields relevant to a specific web request
   }
   // A new bean is created for each HTTP request.
   ```

4. **Session:**

   - **Lifecycle:** A single instance per HTTP session; valid for the duration of a session.
   - **Example:** A user's shopping cart in an e-commerce application that persists across multiple requests in the session.

   ```java
   @Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
   @Component
   public class ShoppingCart {
       // Session-specific data (e.g., shopping cart items)
   }
   // A single instance per user session.
   ```

5. **Application:**

   - **Lifecycle:** A single instance per the lifecycle of a **`ServletContext`**.
   - **Example:** Beans that hold application-wide settings or shared data valid across all users and sessions.

   ```java
   @Scope(value = WebApplicationContext.SCOPE_APPLICATION)
   @Component
   public class ApplicationSettings {
       // Application-wide settings or data
   }
   // Same instance used across all sessions and requests.
   ```

6. **WebSocket:**

   - **Lifecycle:** A single instance per WebSocket connection.
   - **Example:** A bean managing user-specific data in a WebSocket-based chat application.

   ```java
   @Scope(value = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
   @Component
   public class WebSocketUserPreferences {
       // Data specific to a WebSocket session
   }
   // Unique instance for each WebSocket session.
   ```

## 14. Configure a bean using XML. If the bean has parameters/dependencies, how can we configure the bean?

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="<http://www.springframework.org/schema/beans>"
       xmlns:xsi="<http://www.w3.org/2001/XMLSchema-instance>"
       xsi:schemaLocation="<http://www.springframework.org/schema/beans>
                           <http://www.springframework.org/schema/beans/spring-beans.xsd>">

    <!-- DataSource Bean -->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
        <property name="username" value="root"/>
        <property name="password" value="password"/>
    </bean>

    <!-- DatabaseService Bean -->
    <bean id="databaseService" class="com.example.DatabaseService">
        <property name="dataSource" ref="dataSource"/>
    </bean>

</beans>
```

## 15. What is the @configuration and @bean?

1. **@Configuration:**

   - **Purpose:** This annotation indicates that a class declares one or more **`@Bean`** methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime.

   - **Usage:** Typically, **`@Configuration`** is used on classes that define beans for application context.

   - **Example:**

     ```java
     @Configuration
     public class AppConfig {
         // Define bean configurations here
     }
     ```

2. **@Bean:**

   - **Purpose:** This annotation is used on a method to indicate that it returns a bean to be managed by the Spring container. It's a way to programmatically define a Spring bean in a **`@Configuration`** annotated class.

   - **Usage:** Used in methods within a class annotated with **`@Configuration`**. Each **`@Bean`** annotated method creates and returns an object which is registered as a bean.

   - **Example:**

     ```java
     @Configuration
     public class AppConfig {
         @Bean
         public MyService myService() {
             return new MyService();
         }
     }
     ```

## 16. How do you handle exceptions in Spring?

1. **@ExceptionHandler:**

   - Used within a controller to handle exceptions that are thrown during the execution of handler methods within the same controller.

   - Example:

     ```java
     @Controller
     public class MyController {
         @ExceptionHandler(Exception.class)
         public ModelAndView handleError(Exception ex) {
             // Handle exception and return response
         }
     }
     ```

2. **ControllerAdvice:**

   - A global error handling mechanism that can handle exceptions across multiple controllers.

   - Example:

     ```java
     @ControllerAdvice
     public class GlobalExceptionHandler {
         @ExceptionHandler(Exception.class)
         public ResponseEntity<String> handleException(Exception ex) {
             // Handle exception and return response
         }
     }
     ```

3. **ResponseEntityExceptionHandler:**

   - A convenient base class for **`@ControllerAdvice`** classes that wish to provide centralized exception handling across all **`@RequestMapping`** methods.

   - Example:

     ```java
     @ControllerAdvice
     public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler {
         // Override methods to handle specific exceptions
     }
     ```

## 17. How do you do the validations in Spring? And list some validation annotations you know.

1. **Using Validation Annotations in Your Model:**

   - Annotate your model attributes with validation constraints.

   - Example:

     ```java
     public class User {
         @NotNull
         private String name;
     
         @Email
         private String email;
     
         @Min(18)
         private int age;
     
         // Getters and Setters
     }
     ```

2. **Enabling Validation in Controller Methods:**

   - Use the **`@Valid`** or **`@Validated`** annotation in your controller methods to trigger the validation process on the incoming objects.

   - Example:

     ```java
     @PostMapping("/users")
     public ResponseEntity<?> createUser(@Valid @RequestBody User user) {
         // Method logic
     }
     ```

3. **Handling Validation Errors:**

   - You can handle validation errors in your controller methods, typically using a **`BindingResult`** object.

   - Example:

     ```java
     @PostMapping("/users")
     public ResponseEntity<?> createUser(@Valid @RequestBody User user, BindingResult result) {
         if (result.hasErrors()) {
             // Handle errors
         }
         // Continue processing
     }
     ```

## 18. What is the actuator? List some endpoints it provides.

- **@NotNull:** Checks that the annotated value is not null.
- **@NotEmpty:** Checks that the annotated string, collection, map, or array is not null or empty.
- **@NotBlank:** Checks that the annotated string is not null and the trimmed length is greater than zero.
- **@Email:** Checks that the annotated string is a valid email address.
- **@Size(min=, max=):** Checks that the annotated string's size is between the specified min and max.
- **@Min(value):** Checks that the annotated number is greater than or equal to the specified value.
- **@Max(value):** Checks that the annotated number is less than or equal to the specified value.
- **@Pattern(regex=):** Checks if the annotated string matches the specified regular expression.
- **@Positive:** Checks that the annotated number is positive.
- **@Negative:** Checks that the annotated number is negative.

## 19. What is JPA? And what is Hibernate?

**JPA (Java Persistence API):**

- It's a set of rules or guidelines in Java for saving data in databases.
- Think of it like a set of instructions telling Java how to store and get data from a database.
- It helps you work with data using Java objects, instead of complex SQL queries.

**Hibernate:**

- Hibernate is a tool that follows JPA's rules.
- It helps Java programs to easily interact with databases.
- It does more than JPA, like better handling of how data is saved and retrieved.

## 20. What is Hikari? What are the benefits of connection pooling?

**HikariCP (Hikari Connection Pool):**

- **What It Is:** HikariCP is a very fast and lightweight Java connection pool. In the context of databases, a connection pool is a cache of database connections maintained so that the connections can be reused when future requests to the database are made.
- **Key Features:** HikariCP is known for its performance and efficiency. It's often considered the fastest connection pool in the Java ecosystem.

**Benefits of Connection Pooling:**

1. **Improved Performance:** Reusing existing connections significantly reduces the overhead of creating new connections for every database request, leading to faster database interactions.
2. **Resource Management:** Connection pooling helps in efficiently managing a limited number of database connections, preventing overuse of resources.
3. **Reduced Latency:** By avoiding frequent opening and closing of database connections, overall latency is reduced, making applications more responsive.
4. **Better Scalability:** It allows applications to handle a larger number of database transactions, improving scalability.
5. **Consistent Experience:** Connection pooling helps in providing a more consistent experience to users as it avoids the fluctuations in response times caused by frequent connection creation and closure.

## 21. What are the @OneToMany, @ManyToOne, @ManyToMany annotations? Write some examples.

1. **@OneToMany:**

   - **Description:** This annotation defines a one-to-many relationship between two entities.

   - **Example:** A **`User`** can have multiple **`PhoneNumbers`**, but each **`PhoneNumber`** is associated with only one **`User`**.

     ```java
     @Entity
     public class User {
         @Id
         private Long id;
     
         @OneToMany(mappedBy = "user")
         private Set<PhoneNumber> phoneNumbers;
         // ...
     }
     
     @Entity
     public class PhoneNumber {
         @Id
         private Long id;
     
         @ManyToOne
         @JoinColumn(name = "user_id")
         private User user;
         // ...
     }
     ```

2. **@ManyToOne:**

   - **Description:** This annotation defines a many-to-one relationship. It's the inverse of **`@OneToMany`**.
   - **Example:** In the above example, the **`PhoneNumber`** entity has a many-to-one relationship with **`User`**.

3. **@ManyToMany:**

   - **Description:** This annotation defines a many-to-many relationship between two entities.

   - **Example:** A **`Student`** can enroll in multiple **`Course`**s, and a **`Course`** can have multiple **`Student`**s enrolled.

     ```java
     @Entity
     public class Student {
         @Id
         private Long id;
     
         @ManyToMany
         @JoinTable(
             name = "student_course",
             joinColumns = @JoinColumn(name = "student_id"),
             inverseJoinColumns = @JoinColumn(name = "course_id")
         )
         private Set<Course> courses;
         // ...
     }
     
     @Entity
     public class Course {
         @Id
         private Long id;
     
         @ManyToMany(mappedBy = "courses")
         private Set<Student> students;
         // ...
     }
     ```

## 22. What is the cascade = CascadeType.ALL, orphanRemoval = true? And what are the other CascadeType and their features? In which situation do we choose which one?

1. Cascade Types:
   - **CascadeType.ALL:** This applies all cascading effects to the related entity (like persist, remove, refresh, merge, and detach).
   - **CascadeType.PERSIST:** Cascade the persist operation. When the parent entity is saved, it also saves the related entity.
   - **CascadeType.MERGE:** Cascade the merge operation. When the parent entity is merged, the related entity is also merged.
   - **CascadeType.REMOVE:** Cascade the remove operation. When the parent entity is deleted, the related entity is also deleted.
   - **CascadeType.REFRESH:** Cascade the refresh operation. It refreshes the related entity's state from the database.
   - **CascadeType.DETACH:** Cascade the detach operation. When the parent entity is detached from the persistence context, the related entity is also detached.
2. OrphanRemoval:
   - **Usage:** **`orphanRemoval`** is a boolean flag. When set to **`true`**, it means that if a child entity is removed from the collection of the parent entity, it will be removed from the database, effectively treating it as an orphan.
   - **Example:** In a one-to-many relationship between **`Post`** and **`Comment`**, if a **`Comment`** is removed from the **`Post`**'s comment list, it will be deleted from the database if **`orphanRemoval`** is **`true`**.

**Author and Book Entities with CascadeType and orphanRemoval:**

1. **Author Entity:**

   ```java
   @Entity
   public class Author {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
   
       private String name;
   
       @OneToMany(mappedBy = "author", cascade = CascadeType.ALL, orphanRemoval = true)
       private List<Book> books = new ArrayList<>();
   
       // Getters and Setters
   }
   ```

2. **Book Entity:**

   ```java
   @Entity
   public class Book {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
   
       private String title;
   
       @ManyToOne
       @JoinColumn(name = "author_id")
       private Author author;
   
       // Getters and Setters
   }
   ```

   - In the **`Author`** entity, **`@OneToMany`** annotation maps the one-to-many relationship with the **`Book`** entity. The **`cascade = CascadeType.ALL`** means all persistence operations (like persist, remove, merge) on the **`Author`** entity will be cascaded to the associated **`Book`** entities. This is useful when the state and lifecycle of the child entities (**`Book`**) are tightly coupled with the parent entity (**`Author`**).
   - The **`orphanRemoval = true`** attribute ensures that if a **`Book`** is removed from the **`Author`**'s book list, it will also be removed from the database. This is useful for cleaning up child entities that should not exist without their parent entity.
   - In the **`Book`** entity, **`@ManyToOne`** maps the many-to-one side of the relationship, with the **`@JoinColumn`** specifying the foreign key column in the **`Book`** table.

## 23. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? What is the difference? In which situation do you choose which one?

1. FetchType.LAZY:
   - **Description:** This fetch type loads the related entities lazily, i.e., the data is loaded on demand. For instance, if you have an **`Author`** entity with a collection of **`Book`** entities, using **`FetchType.LAZY`** on the relationship means the **`Book`** data isn't loaded until you specifically access it in your code.
   - **When to Use:** Use **`LAZY`** fetching to improve application performance and reduce memory usage, especially when you don't always need related data. It's the preferred approach in most cases to avoid the overhead of loading unnecessary data.
2. FetchType.EAGER:
   - **Description:** This fetch type loads the related entities eagerly, i.e., all the data is loaded upfront. Using the same example, with **`FetchType.EAGER`**, the **`Book`** entities would be loaded from the database as soon as the **`Author`** entity is loaded.
   - **When to Use:** Use **`EAGER`** fetching when you are sure that you will need the related entities every time you fetch the parent entity. It can be useful for small datasets or when dealing with data that is frequently accessed together.

## 24. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?

## 25. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.

1. **JPA Naming Convention for Tables and Columns:**

   - **Default Strategy:** By default, JPA uses the entity class name as the table name and the entity field names as column names.

   - **Customization:** You can customize these mappings using **`@Table`** and **`@Column`** annotations. For example, an **`Employee`** entity with a **`firstName`** field by default maps to an "Employee" table and a "firstName" column, but you can change these using annotations.

   - **Example:**

     ```java
     @Entity
     @Table(name = "employees")
     public class Employee {
         @Id
         private Long id;
     
         @Column(name = "first_name")
         private String firstName;
         // Other fields
     }
     ```

2. **Repository Method Naming Convention:**

   - **Query Derivation:** Spring Data JPA repositories can automatically implement query methods based on method name conventions.

   - **Rules:** The method name typically starts with **`find...By`**, **`count...By`**, etc., followed by property names of the entity.

   - **No Need to Implement:** You don't have to implement these methods. Spring Data JPA creates the implementation automatically based on the naming convention.

   - **Example:**

     ```java
     public interface EmployeeRepository extends JpaRepository<Employee, Long> {
         List<Employee> findByLastName(String lastName);
         Employee findByEmail(String email);
     }
     ```

## 26. What is JPQL?

JPQL (Java Persistence Query Language) is a query language used in JPA (Java Persistence API) for making queries against entities stored in a relational database. It is similar to SQL but operates at the object level rather than the table level.

```java
@Entity
public class Employee {
    @Id
    private Long id;

    private String firstName;
    private String lastName;

    // Constructors, getters, setters
}
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    @Query("SELECT e FROM Employee e WHERE e.lastName = :lastName")
    List<Employee> findByLastName(@Param("lastName") String lastName);
}
```

## 27. What is @NamedQuery and @NamedQueries?

1. **@NamedQuery:**

   - **Purpose:** Used to define a single query associated with an entity.

   - **Usage:** This annotation is placed either on the entity class or in an XML mapping file. It requires a unique name and the query itself.

   - **Example:**

     ```java
     @Entity
     @NamedQuery(name = "Employee.findByLastName", query = "SELECT e FROM Employee e WHERE e.lastName = :lastName")
     public class Employee {
         // Class contents
     }
     ```

2. **@NamedQueries:**

   - **Purpose:** A container annotation used to hold multiple **`@NamedQuery`** annotations.

   - **Usage:** Useful when you want to declare several named queries for a single entity.

   - **Example:**

     ```java
     @Entity
     @NamedQueries({
         @NamedQuery(name = "Employee.findByLastName", query = "SELECT e FROM Employee e WHERE e.lastName = :lastName"),
         @NamedQuery(name = "Employee.countAll", query = "SELECT COUNT(e) FROM Employee e")
     })
     public class Employee {
         // Class contents
     }
     ```

## 28. What is @Query? In which Interface do we write the SQL or JPQL?

**`@Query`** is an annotation used in Spring Data JPA to define custom queries using JPQL (Java Persistence Query Language) or native SQL directly on repository methods. It allows for more flexibility and complex operations than the standard query derivation from method names.

**Where to Use `@Query`:**

- The **`@Query`** annotation is typically used in repository interfaces that extend Spring Data JPA repositories like **`JpaRepository`** or **`CrudRepository`**.

**Writing JPQL or SQL Queries:**

- You can write either JPQL or native SQL queries using the **`@Query`** annotation. By default, the value of the **`@Query`** annotation is assumed to be a JPQL query. If you want to use native SQL, you need to set the **`nativeQuery`** attribute to **`true`**.

**Example with JPQL:**

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    @Query("SELECT e FROM Employee e WHERE e.lastName = ?1")
    List<Employee> findByLastName(String lastName);
}
```

**Example with Native SQL:**

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    @Query(value = "SELECT * FROM employees WHERE last_name = ?1", nativeQuery = true)
    List<Employee> findByLastName(String lastName);
}
```

## 29. What is HQL and Criteria Queries?

**HQL (Hibernate Query Language):**

- **Description:** HQL is an object-oriented query language, similar to SQL, but instead of operating on tables and columns, HQL works with persistent objects and their properties. It's part of Hibernate, an ORM (Object-Relational Mapping) framework for Java.

- **Purpose:** HQL allows users to write queries against data that can be understood in terms of objects, classes, and inheritance, rather than tables and columns.

- **Example:**This HQL query selects **`Employee`** objects where the **`id`** is 10.

  ```java
  String hql = "FROM Employee E WHERE E.id = 10";
  Query query = session.createQuery(hql);
  List results = query.list();
  ```

**Criteria Queries:**

- **Description:** The Criteria API is a programmatically built, type-safe query API provided by Hibernate. It's used to define queries through the construction of object-oriented criteria.

- **Purpose:** It's useful for building complex queries programmatically, where the structure of the query might be dynamic and depend on various conditions.

- **Example:**This Criteria query does the same as the HQL example, selecting **`Employee`** objects where the **`id`** is 10.

  ```java
  CriteriaBuilder cb = session.getCriteriaBuilder();
  CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
  Root<Employee> root = cr.from(Employee.class);
  cr.select(root).where(cb.equal(root.get("id"), 10));
  Query<Employee> query = session.createQuery(cr);
  List<Employee> results = query.getResultList();
  ```

## 30. What is EntityManager?

**`EntityManager`** is a fundamental part of the Java Persistence API (JPA), acting as the primary interface for interacting with the persistence context. The persistence context is where entities (Java objects) are managed in their lifecycle by JPA.

**Key Responsibilities of `EntityManager`:**

1. **Managing Entities:** It's responsible for managing entity instances, including operations like persisting, removing, finding, and querying entities.
2. **Transaction Management:** **`EntityManager`** provides support for transactions, allowing for operations to be executed within a transactional context to maintain data integrity.
3. **Query Execution:** It allows the execution of JPQL (Java Persistence Query Language), Criteria Queries, and named queries.
4. **Lifecycle Management:** **`EntityManager`** manages the lifecycle states of entities (New, Managed, Detached, Removed).

**Example Usage:**

```java
EntityManager em = entityManagerFactory.createEntityManager();
em.getTransaction().begin();

Employee employee = new Employee();
employee.setName("John Doe");
em.persist(employee);

em.getTransaction().commit();
em.close();
```

## 31. What is SessionFactory and Session?

1. SessionFactory:
   - **Role:** It's a factory class that creates **`Session`** objects. It's a heavyweight object, usually created during application start-up and kept for later use. The **`SessionFactory`** is a thread-safe object and used by all the threads of an application.
   - **Functionality:** It holds the configuration data for Hibernate (like database connection properties, mapping files, etc.), and it's used to create **`Session`** instances.
   - **Lifecycle:** Typically, there's a single **`SessionFactory`** instance per database, and it's often treated as a singleton.
2. Session:
   - **Role:** The **`Session`** is a light object and the main runtime interface between a Java application and Hibernate. It is used to perform database operations on entities such as saving, retrieving, updating, and deleting records.
   - **Functionality:** It wraps a JDBC connection and acts as a factory for **`Transaction`**. It also maintains a cache of persistent entities and ensures their synchronization with the database.
   - **Lifecycle:** A **`Session`** is opened from the **`SessionFactory`** and should be closed after the operations are completed. Unlike **`SessionFactory`**, it is not thread-safe and is meant to be used by a single thread at a time.

**Example Code:**

```java
// Creating the SessionFactory (usually done during application startup)
SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();

// Opening a Session
Session session = sessionFactory.openSession();
session.beginTransaction();

// Perform operations
Employee employee = new Employee("John Doe");
session.save(employee);

// Commit and close
session.getTransaction().commit();
session.close();
```

## 32. What is Transaction? How to manage your transaction?

**Transaction in the Context of Databases and ORM:**

- **Definition:** A transaction in database systems and ORM (Object-Relational Mapping) frameworks like Hibernate or JPA is a sequence of operations performed as a single logical unit of work. A transaction has four main properties, known as ACID properties: Atomicity, Consistency, Isolation, and Durability.
- **Purpose:** Transactions ensure data integrity and consistency in the face of errors, hardware failures, or concurrent access.

**How to Manage Transactions:**

1. **Declarative Transaction Management:**

   - This is the preferred approach in Spring and JPA/Hibernate.

   - Transactions are managed using annotations like **`@Transactional`** in Spring.

   - Example:

     ```java
     @Transactional
     public void performBusinessOperation() {
         // Business logic that involves database operations
     }
     ```

   - The **`@Transactional`** annotation automatically starts and commits/rolls back transactions before and after the annotated method.

2. **Programmatic Transaction Management:**

   - Involves managing transactions programmatically in the code.

   - You manually begin, commit, and rollback transactions.

   - Example in Hibernate:

     ```java
     Session session = sessionFactory.openSession();
     Transaction tx = null;
     
     try {
         tx = session.beginTransaction();
         // Business logic
         tx.commit();
     } catch (RuntimeException e) {
         if (tx != null) tx.rollback();
         throw e;
     } finally {
         session.close();
     }
     ```

3. **Using TransactionTemplate in Spring:**

   - Spring provides **`TransactionTemplate`** for programmatic transaction management.

   - It offers a template for executing operations within a transaction.

   - Example:

     ```java
     transactionTemplate.execute(new TransactionCallbackWithoutResult() {
         protected void doInTransactionWithoutResult(TransactionStatus status) {
             // Business logic
         }
     });
     ```

## 33. What is Hibernate Caching?

**Hibernate Caching** is like a memory area where Hibernate stores data so it doesn't have to keep asking the database for it. This improves the speed and performance of your application. There are two main types:

1. First-Level Cache:
   - **What It Is:** It's like a short-term memory for each session or interaction with the database. Hibernate automatically uses it.
   - **How It Works:** If you ask for the same data again during the same session, Hibernate gives it to you from this cache instead of going back to the database.
2. Second-Level Cache:
   - **What It Is:** It's like a long-term memory shared by all sessions or interactions.
   - **How It Works:** If some data is not in the first-level cache, Hibernate looks in the second-level cache before asking the database.
   - **Setup:** It's not set up by default; you have to turn it on and configure it.

**Why It's Good:**

- **Speeds Up Your App:** By reducing the number of times Hibernate has to ask the database for data, your app runs faster.
- **Reduces Database Load:** The database doesn't get as many requests, so it can work more efficiently.

## 34. What is the difference between first-level cache and second-level cache?

1. First-Level Cache:
   - **Scope:** It is associated with the Hibernate **`Session`** object. Each session has its own first-level cache.
   - **Lifecycle:** The cache only exists for the duration of the session. Once the session is closed, the first-level cache is cleared.
   - **Automatic:** It is enabled by default and cannot be disabled. Every time an entity is fetched, it is stored in this cache.
   - **Usage:** It's mainly useful within a single transaction or a single unit of work. It helps to avoid repeated database calls within the same session for the same entity.
   - **Limitation:** Since it's tied to a single session, it doesn't benefit from data accessed in other sessions.
2. Second-Level Cache:
   - **Scope:** It is associated with the **`SessionFactory`** and is shared across sessions. It's a global cache.
   - **Lifecycle:** The cache persists beyond the lifespan of a single session and can be accessed by other sessions.
   - **Configuration:** It's not enabled by default and requires explicit configuration. You can also configure what gets cached and for how long.
   - **Usage:** Useful for caching data that is frequently read but rarely changed. It's beneficial in a scenario where data is accessed in multiple sessions.
   - **Third-Party Integration:** Often requires integration with third-party caching libraries like EHCache, Infinispan, or Hazelcast.

**Key Differences:**

- **Scope and Availability:** The first-level cache is local to a session, whereas the second-level cache is shared across sessions.
- **Lifespan:** The first-level cache is short-lived (session scope), whereas the second-level cache can retain data across multiple sessions.
- **Configuration:** The first-level cache is always on, but the second-level cache needs to be explicitly enabled and configured.