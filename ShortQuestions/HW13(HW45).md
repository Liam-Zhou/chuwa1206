## What is the authentication?
Authentication is the process of verifying the identity of a user, system, or entity. 

It ensures that the entity claiming to be a particular identity is, in fact, that identity. This is typically done through the use of credentials such as usernames and passwords, biometric information, security tokens, or other means of proving identity.
## What is the authorization?
Authorization,  occurs after authentication and involves determining what actions or resources a verified user or system is allowed to access. 

Once a user's identity is authenticated, authorization defines what actions or operations that user is permitted to perform within the system. This is usually based on the user's role, permissions, or other attributes. Authorization helps control and manage access to sensitive information and functionalities.
## What is the difference between authentication and authorization?
**Authentication vs. Authorization:**

|S.NO|Authentication|Authorization|
|---|---|---|
|1.|In the authentication process, the identity of users is checked for providing access to the system.|In the authorization process, a person's or user's authorities are checked for accessing resources.|
|2.|In the authentication process, users or persons are verified.|In the authorization process, users or persons are validated.|
|3.|Authentication is done before the authorization process.|Authorization is done after the authentication process.|
|4.|Authentication usually requires user's login details.|Authorization requires user's privilege or security levels.|
|5.|Authentication determines whether the person is a user or not.|Authorization determines what permissions the user has.|
|6.|Generally, information is transmitted through an ID Token in the authentication process.|Generally, information is transmitted through an Access Token in the authorization process.|
|7.|Example: Employees in a company are required to authenticate through the network before accessing their company email.|Example: After an employee successfully authenticates, the system determines what information the employees are allowed to access.|
In summary, authentication verifies the identity of a user, system, or entity, while authorization determines what actions or resources that authenticated entity is allowed to access
## What is HTTP Session?
  
An HTTP session is a mechanism used to maintain stateful information about a user's interactions with a web application across multiple requests and responses. HTTP, or Hypertext Transfer Protocol, is a stateless protocol, meaning that each request from a client to a server is independent and doesn't inherently carry information about the previous requests.

Key points about HTTP sessions:

1. **Stateful Communication:** HTTP sessions enable stateful communication by allowing the server to associate data with a specific user or client. This is particularly important for applications that require user authentication, shopping carts in e-commerce sites, or any scenario where maintaining user-specific data is necessary.
    
2. **Cookies or URL Rewriting:** HTTP sessions are often implemented using cookies or URL rewriting. A unique identifier (session ID) is assigned to each user, and this identifier is sent with each subsequent request to link it to the correct session data on the server.
    
3. **Server-Side Storage:** The actual session data is typically stored on the server side. This can include information such as user preferences, authentication status, and other relevant data. The session ID provided by the client allows the server to retrieve the corresponding session data.
    
4. **Session Lifecycle:** Sessions have a lifecycle that includes creation, maintenance, and eventual expiration. The server may set a timeout for a session, and if there is no activity within that time, the session may be considered expired.
    
5. **Security Considerations:** Implementing secure practices for handling session data is crucial to prevent unauthorized access. This includes using secure connections (HTTPS) and secure methods for storing and transmitting session IDs.
## What is Cookie?
A cookie is a small piece of data stored on the user's device by the web browser while browsing a website. Cookies are used to track and store information about the user's interactions with the website, enabling various functionalities and providing a personalized browsing experience. Here are key characteristics and uses of cookies:

1. **Purpose:**
    
    - **Session Management:** Cookies are commonly used for session management, allowing websites to recognize users and remember their preferences or login status during a session.
    - **Personalization:** Cookies can store user preferences, language settings, and other personalized information to enhance the user experience.
2. **Structure:**
    
    - **Key-Value Pairs:** Cookies typically consist of key-value pairs, where each pair represents a specific piece of information.
    - **Domain and Path:** Cookies are associated with a specific domain and path, determining the scope of the cookie and when it should be sent to the server.
3. **Types of Cookies:**
    
    - **Session Cookies:** Temporary cookies that are deleted when the user closes the browser.
    - **Persistent Cookies:** Stored on the user's device for a specified duration, even after closing the browser.
    - **Secure Cookies:** Encrypted and transmitted only over secure (HTTPS) connections for enhanced security.
4. **Cookie Lifecycle:**
    
    - **Creation:** Cookies are created by the server and sent to the user's browser through the HTTP response.
    - **Storage:** Cookies are stored on the user's device and included in subsequent HTTP requests to the same domain.
    - **Expiration:** Cookies may have an expiration date, after which they are automatically deleted. This can be set by the server or be a session cookie that expires when the browser is closed.
5. **Security and Privacy Considerations:**
    
    - **Secure and HttpOnly Flags:** Cookies can be marked as "Secure" to ensure they are only transmitted over secure connections, and "HttpOnly" to prevent access through client-side scripts.
    - **SameSite Attribute:** Defines when cookies should be sent with cross-site requests, enhancing security and privacy.
6. **Common Uses:**
    
    - **Authentication:** Storing session identifiers for user authentication.
    - **Tracking:** Collecting analytics data to understand user behavior.
    - **Personalization:** Customizing content based on user preferences.
    - **Shopping Carts:** Maintaining the state of a user's shopping cart on an e-commerce site.
## What is the difference between Session and Cookie?
1. **Storage Location:**
    
    - **Session:** The session data is stored on the server side. Only a unique session identifier (usually stored in a cookie) is stored on the client side.
    - **Cookie:** Cookies are stored on the user's device (client side). They contain information sent by the server and are included in subsequent HTTP requests to the same domain.
2. **Lifecycle:**
    
    - **Session:** The session typically has a defined start and end. It is created when a user accesses a website and expires after a period of inactivity or when the user closes the browser.
    - **Cookie:** Cookies can be either session cookies (temporary, deleted when the browser is closed) or persistent cookies (stored on the device for a specified duration).
3. **Content:**
    
    - **Session:** Stores arbitrary data on the server side, often related to user authentication, preferences, and other session-specific information.
    - **Cookie:** Stores small pieces of data on the client side, often used for user preferences, tracking, and personalization.
4. **Communication:**
    
    - **Session:** Session data is managed and communicated between the server and the client using mechanisms such as session IDs, often transmitted through cookies or URL rewriting.
    - **Cookie:** Information stored in cookies is automatically included in the HTTP requests made by the browser to the associated domain.
5. **Scope:**
    
    - **Session:** The scope of a session is limited to a specific user and is typically associated with a user's login session or visit to a website.
    - **Cookie:** Cookies can be used for various purposes beyond sessions, such as tracking user behavior, personalizing content, and managing user preferences.

In summary, a session is a server-side mechanism for persistently storing information about a user's interactions, while a cookie is a client-side storage mechanism used to track and store small pieces of data. Sessions often use cookies to manage session IDs, but they are distinct concepts with different purposes and implementations
## How do we use session and cookie to keep user information across the the application?
### Using Sessions:

1. **Session Creation:**
    
    - When a user accesses your application, create a new session on the server side.
    - Assign a unique session ID to the user, and store any necessary user information (e.g., user ID, username, preferences) on the server associated with that session.
2. **Session ID Transmission:**
    
    - Send the session ID to the client, typically by setting a cookie containing the session ID in the HTTP response.
3. **Subsequent Requests:**
    
    - In each subsequent request from the client, include the session ID, usually by automatically sending the session cookie with each HTTP request.
4. **Server-Side Retrieval:**
    
    - On the server side, retrieve the session ID from the incoming request.
    - Use the session ID to look up the associated user information stored on the server.
5. **Session Expiry:**
    
    - Set a timeout for the session to handle cases of inactivity. If a user doesn't interact with the application within a specified time, consider the session expired.

### Using Cookies:

1. **Cookie Creation:**
    
    - When a user logs in or performs an action that requires storing information, create a cookie on the server side.
    - Include the necessary user information in the cookie.
2. **Cookie Transmission:**
    
    - Send the cookie to the client by setting it in the HTTP response.
3. **Subsequent Requests:**
    
    - In each subsequent request from the client, the cookie containing user information is automatically included in the HTTP request headers.
4. **Server-Side Retrieval:**
    
    - On the server side, retrieve the cookie from the incoming request.
    - Extract the user information stored in the cookie.
5. **Cookie Expiry:**
    
    - Set an expiration date for the cookie. This can be a session cookie (expires when the browser is closed) or a persistent cookie (expires after a specified duration).
## What is JWT?
  
JWT stands for JSON Web Token. It is a compact, URL-safe means of representing claims between two parties. JWTs are often used for authentication and authorization purposes in web development. They consist of a string encoded in a JSON format that can be easily transmitted between parties and verified for integrity.

**Header:**

- The header typically consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC SHA256 or RSA.
```java
{
  "alg": "HS256",
  "typ": "JWT"
}

```
**Payload:**

- The payload contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private claims.
```java
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}

```

**Signature:**

- To create the signature part, a base64Url encoding of the header and payload is generated, and it is signed with a secret key (or a public/private key pair in the case of RSA). This signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.
```java
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)

```
## What is the spring security filter?
Spring Security is a powerful and customizable authentication and access control framework for Java applications, particularly those built using the Spring framework. The Spring Security framework includes a set of filters that work together to provide various security features. These filters are part of the security filter chain, and each filter is responsible for handling specific aspects of the authentication and authorization process.
## Decribe how do JWT work
1. Client post /authenticate with username and password
2. Server validate username and password. 
3. Generate JWT using secret key.
4. Return the generated JWT to Client
5. JWT is saved on Client side(Local Storage/Cookie).
6. Encode JWT in HTTP Header. Server validate the JWT.

Detailed:
1. **Client Requests Authentication:**
    
    - The client initiates the authentication process by sending a POST request to the `/authenticate` endpoint with the username and password.
2. **Server Validates Credentials:**
    
    - The server validates the provided username and password against its database or authentication system.
3. **Generate JWT:**
    
    - If the credentials are valid, the server generates a JWT (JSON Web Token) using a secret key. The JWT typically includes claims such as the user's ID, username, and any relevant information.
4. **JWT Response:**
    
    - The server responds to the client's authentication request with the generated JWT. This response may include the JWT in the response body or as part of the response headers.
5. **Client Stores JWT:**
    
    - The client stores the received JWT securely. Common storage locations include local storage, session storage, or HTTP cookies.
6. **JWT in Authorization Header:**
    
    - For subsequent requests to protected resources, the client includes the JWT in the `Authorization` header of the HTTP request. This is commonly done using the "Bearer" authentication scheme.
    
    makefileCopy code
    
    `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.[JWT_PAYLOAD].[SIGNATURE]`
    
    - The `JWT_PAYLOAD` part is the base64-encoded header and payload.
7. **Server Validates JWT:**
    
    - The server receives the HTTP request with the JWT in the `Authorization` header.
    - It decodes the JWT to extract the header and payload.
    - The server then verifies the signature using the secret key.
    - If the signature is valid, the server checks the claims in the payload, including expiration, issuer, and other relevant information.
8. **Access Decision:**
    
    - If the JWT is valid and the claims are acceptable, the server grants access to the requested resource. If the JWT is invalid, expired, or the claims are not satisfactory, access is denied.
## Do you use any Encoder to encode Password?

- The Spring Security framework, for example, often uses BCrypt for password encoding.`PasswordEncoder` is provided by `spring-boot-starter-security`
## What is UserDetailService? AuthenticationProvider?AuthenticationManager? AuthenticationFilter?

### **UserDetailsService:**

- The `UserDetailsService` interface is used to retrieve user-related data. It has a method called `loadUserByUsername` that takes a username as an argument and returns a `UserDetails` object.
- `UserDetails` typically contains information about the user, such as username, password, authorities (roles), and whether the account is enabled, expired, or locked.
### **AuthenticationProvider:**

- An `AuthenticationProvider` is responsible for authenticating users based on the provided `Authentication` object. It can support different authentication mechanisms.
- Spring Security comes with various authentication providers, including `DaoAuthenticationProvider` (which uses a `UserDetailsService`) and `JwtAuthenticationProvider` (for JWT-based authentication).
- Custom authentication providers can be implemented to support specific authentication mechanisms.
### **AuthenticationManager:**

- The `AuthenticationManager` is a higher-level component that delegates the authentication process to one or more `AuthenticationProviders`.
- It iterates through the providers and asks each one if it can authenticate the provided `Authentication` object.
- If a provider can authenticate the request, the `AuthenticationManager` returns the authenticated `Authentication` object.
### **AuthenticationFilter:**

- An `AuthenticationFilter` is responsible for processing incoming authentication requests.
- It typically intercepts requests to specific endpoints, extracts authentication details from the request (e.g., username and password, JWT), and passes them to the `AuthenticationManager`.
- Example filters include `UsernamePasswordAuthenticationFilter` (for form-based authentication) and `JwtAuthenticationFilter` (for JWT-based authentication).
- Custom filters can be implemented to support additional authentication mechanisms.
## What is the disadvantage of Session? how to overcome the disadvantage?

1. **Server-Side Storage:**
    
    - **Disadvantage:** Sessions typically require server-side storage to store session data, which can lead to scalability challenges as the number of users increases.
    - **Solution:** Consider using stateless alternatives like JSON Web Tokens (JWTs) for scenarios where server-side storage becomes a bottleneck. JWTs are self-contained and do not rely on server storage.
2. **Server Overhead:**
    
    - **Disadvantage:** Server overhead increases as the number of concurrent users grows, especially when managing large session data.
    - **Solution:** Optimize session management by periodically cleaning up expired sessions. Additionally, use efficient session storage mechanisms or distribute session management across multiple servers (session clustering).
3. **Resource Consumption:**
    
    - **Disadvantage:** Session data consumes server resources, leading to increased memory usage.
    - **Solution:** Carefully design the session data structure to store only essential information. Implement mechanisms to clear or offload inactive sessions. Consider external session storage solutions.
4. **Session Hijacking:**
    
    - **Disadvantage:** Sessions are susceptible to session hijacking or session fixation attacks if not properly secured.
    - **Solution:** Implement secure session management practices, such as using secure cookies, enforcing HTTPS, and regenerating session IDs after login. Additionally, consider implementing mechanisms like IP validation or user-agent validation.
5. **Scalability Issues:**
    
    - **Disadvantage:** Scaling horizontally becomes challenging as the application needs to share session data across multiple servers.
    - **Solution:** Explore stateless authentication mechanisms like token-based authentication (JWT) or externalize session storage using solutions like distributed caching or databases.
6. **Storage Limitations:**
    
    - **Disadvantage:** Some storage mechanisms for sessions may have limitations on the amount of data that can be stored.
    - **Solution:** Choose storage mechanisms that align with your application's requirements. If necessary, consider distributed storage solutions to overcome limitations.
## How to get value from application.properties?
Use the `@Value` annotation, the `Environment` object, or the `@ConfigurationProperties` annotation
Example:
```java
@Component 
public class MyComponent { 
	@Value("${property.key}") 
	private String propertyValue;
}
```
## What is the role of configure(HttpSecurity http) and  configure(AuthenticationManagerBuilder auth)?
### `configure(HttpSecurity http)`:

This method is responsible for configuring security settings related to HTTP requests, including access control, authentication, and authorization.
Define rules for which URLs should be secured and specify the roles or authorities required for accessing them.
Configure additional security filters, such as CSRF protection, headers, and custom filters.

### `configure(AuthenticationManagerBuilder auth)`:

This method is responsible for configuring the authentication mechanism, specifying how Spring Security should handle authentication.
It provides:
**In-Memory Authentication:**

- Configure user details and passwords directly in memory.
**Database Authentication:**

- Connect to a database to retrieve user details for authentication.
**Database Authentication:**

- Connect to a database to retrieve user details for authentication.
## What is Spring security authentication and authorization?

### Authentication:

**Authentication** is the process of verifying the identity of a user. In the context of Spring Security, it involves confirming that a user is who they claim to be. The framework supports various authentication mechanisms, including:

1. **In-Memory Authentication:**
    
    - Configuring user details directly in memory, suitable for small applications or testing.
2. **Database Authentication:**
    
    - Authenticating users by retrieving their details from a database.
3. **LDAP Authentication:**
    
    - Integrating with LDAP servers for authentication in enterprise environments.
4. **OAuth 2.0 and OpenID Connect:**
    
    - Supporting authentication using OAuth 2.0 and OpenID Connect for third-party identity providers.
5. **Token-Based Authentication:**
    
    - Using stateless tokens (e.g., JSON Web Tokens) for authentication.
6. **Custom Authentication Providers:**
    
    - Implementing custom authentication providers to support specific authentication mechanisms.

### Authorization:

**Authorization** is the process of determining what actions a user is allowed to perform within the application. Spring Security supports fine-grained authorization through role-based and expression-based access control. Key components include:

1. **Role-Based Access Control:**
    
    - Assigning roles to users, and securing parts of the application based on these roles.
    - Example: Granting access to an "ADMIN" role for administrative features.
2. **Expression-Based Access Control:**
    
    - Defining access control rules using SpEL (Spring Expression Language) expressions.
    - Example: Allowing access if a user has both "READ" and "WRITE" permissions.
3. **Method Security:**
    
    - Securing individual methods based on roles or expressions using annotations.
    - Example: Restricting access to a specific service method based on user roles.
4. **Secured Annotations:**
    
    - Using `@Secured` annotations to declare required roles or permissions for methods.
    - Example: Annotating a controller method with `@Secured("ROLE_USER")`.
5. **Pre and Post Authorization:**
    
    - Pre-authorizing or post-authorizing methods based on specific conditions.
    - Example: Checking if a user has the necessary privileges before executing a method.

Overall, Spring Security provides a comprehensive and flexible framework for handling authentication and authorization in Java applications. By configuring authentication providers, defining access rules, and leveraging various authentication mechanisms, developers can implement robust security measures to protect their applications.