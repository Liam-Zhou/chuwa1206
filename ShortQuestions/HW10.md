## HW 42 
2. `@Configuration` is an annotation used to denote a class as a configuration class. This annotation indicates that the class contains one or more `@Bean` annotated methods and these methods will return object instances that should be registered as beans in the Spring container. 
`@Bean` annotation is used to mark a method, indicating that the method returns an object that should be registered as a bean in the Spring container. 
3. (1) I can custom exception class. For example:
```
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}

```
(2) I can use `@ControllerAdvice` to define a global exception handling class and use `@ExceptionHandler`to annotate methods that
handle specific exceptions. For example:
```
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<String> handleUserNotFound(UserNotFoundException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
    }
}
```
(3) Also can use ResponseEntity to use a specific response.

4. use Validation in DTO or entity object and use @Valid or @Validated in controller methods. 

There are some command validation annotations: `@NotNull`: ensure the field is not null. `@NotEmpty` ensures the field is not empty. 
`@Size(min = , max = )`: restricts character length. `@Min(value)`ensure the number value is not less than specified. 
`@Email`: ensures the field is a valid email address. 

5. `Actuator` is used to monitor and managing the application. For example:
   (1) `health`: shows application health information. 

(2) `info`: Displays basic information of the application.

(3) `metrics` shows various metrics, such as memory usage, GC, HTTP requests. 

(4) `env` Displays environment properties. 

(5) `threaddump` shows a snapshot of the thread state. 

(6) `mappings` shows all URL paths mapped to controllers. 

## HW 43
2. Spring is an open-source Java framework which can simplifying the development of enterprise-level application. 

Spring Boot is a project based on Spring aimed to simplifying the creation and development od Spring application. The 
benefits are (1) Simplified Configuration (2) Embedded Sever (3) Auto-Configuration (4) Production-ready Feature (5) No Code Generation and XML Configuration. 

3. IOC(Inversion of Control): It is a design principle used to reduce coupling between components ina software system. 
In traditional programming, the flow fo the program is controlled by the  program itself,but with inversion of control, this control is 
given to an external system or framework. In SpringBoot, this external system is the Spring Container, which is responsible 
for creating objects, maintaining their life cycle, and managing their dependencies. 

DI(Dependency Injection): It's a method to achieve IOC. In dependency injection, an object's dependencies are not created by the object itself but are provided by an external container. 
The objects just declare what dependencies they need, without having to know how to create them. The Springboot container is responsible for 
injecting these dependencies, making the code more modular, easier to test, and maintain. 

4. `@ComponentScan` is annotation in the Spring framework used to specify which package Spring should scan at startup to find 
classes annotated with `@Component` and its derived annotations(`@Service`, `@Responsitory`, `@Controller`, etc.). These classes 
are then instantiated and registered as beans in the Spring container. 

`@ComponentScan` allows for customizing the scan path. If no path is specified, it defaults to scanning the package of class declaring 
`@ComponentScan` and its sub-packages. 

5. In Spring's XML file, You can use 
```
<context:component-scan base-package="com.example.myapp" />
```
Specifying Package to Scan in Annotation Configuration
```
@Configuration
@ComponentScan("com.example.myapp")
public class AppConfig {
    // Configuration details
}
```
In this example, Spring will scan the `com.example.myapp` package and its sub-packages for all classes annotated with `@Component`
and its derived annotations. 
```
@Configuration
@ComponentScan("com.example.myapp")
public class AppConfig {
    // Configuration details
}
```
In this example, similar to the XML configuration, Spring will scan the `com.example.myapp` package and its sub-packages.

6. `@SpringBootApplication` is a convenience annotation often used to the main class in a Spring Boot application. It encompasses the 
following three important annotations:
   (1) `@Configuration`: Indicates that a class servers as a source of bean definitions.
   (2) `@EnableAutoConfiguration`: Tells Spring Boot to start adding auto-configurations based on classpath setting, other beans, 
and various property settings.
   (3) `@ComponentScan`:Tell Spring to search for other components, configurations, and services in the package containing 
the configuration class. 
7. (1) `Annotation-based`: Use @Component and its specialized annotations(`@Service`, `@Respository`, `@Controller`) directly
   (2) `@Bean` in methods with a configuration class.
   (3) XML-based: define beans in a Spring XML configuration files. 
8. Default name for `@Component` is the class name with the first letter in lowercase. Default name for `@Bean` is the method name. 
9. `@Component` is a generic annotation used for any Spring-managed component. Its primary purpose is for automatic detection and configuration of classes. 
`@Service` is a specialization for `@Component`, used for marking service layer components. Indicates that the classes belongs to the 
`service layer` helping in more precise layering. 
`@Respopsitory` also a specialization of `@Component` used for marketing data access layer components. In addition to layering, 
it provides data access-related exception translation features. 
10. (1) `@Autowired`: can be used on fields, constructors, setter methods. (2) `@Inject`: from the Java Dependency Injection specification
    (3) `@Resource`: provide finer-grained control. Use in variable.
11. (1) filed injection: 
```
@Autowired
private MyService myService;
```
(2) constructor injection:
```
@Autowired
public MyClass(MyService myService) {
    this.myService = myService;
}
```
(3) Setter Injection:
```
private MyService myService;

@Autowired
public void setMyService(MyService myService) {
    this.myService = myService;
}
```
12. Use `@Primary` annotation on one of the beans to indicate that this bean should be given preference among multiple candidates. 

or Specifying Bean Name: If no binary bean is set, you can specify the name of the bean to be injected using the `@Qualifier` annotation during injection. 
13. `BeanFactory` and `ApplicationContext` are two types of containers for managing beans, and they have some differences:
    (1) Feature Richness: `BeanFactory`: Provides basic dependency injection features. `ApplicationContext`: A sub-interface of 
`BeanFactory`, offering more advanced features like event publication, AOP support, internationalization.
    (2) Bean Instantiation Timing:     `BeanFactory`: Uses lazy loading and creates beans only when requested.
    `ApplicationContext`: Loads all singleton beans at startup time.
14. In the Spring framework, the scope of a bean defines its lifecycle. 
```
@Service
public class MySingletonService {
    //...
}
```
```
@Scope("prototype")
public class MyPrototypeService {
    //...
}
```
```
@Component
@Scope("request")
public class MyRequestBean {
    //...
}

```
```
@Component
@Scope("session")
public class MySessionBean {
    //...
}

```
```
@Component
@Scope("application")
public class MyApplicationBean {
    //...
}

```